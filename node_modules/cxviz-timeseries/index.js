'use strict';

var d3           = require('d3');
var EventEmitter = require('events').EventEmitter;
var inherits     = require('util').inherits;
var Schema       = require('./lib/schema');
var format       = require('cxviz-format');
var Draw         = require('./lib/draw');

module.exports = Line;

var MAX_SERIES = 500;
var MAX_RECORDS = 5000;

var ONE_MIN_MS = 1000 * 60;
var ONE_HOUR_MS = ONE_MIN_MS * 60;
var ONE_DAY_MS = ONE_HOUR_MS * 24;
var ONE_WEEK_MS = ONE_DAY_MS * 7;
var DEFAULT_RATIO = 5;

var _dateBisect = d3.bisector(function(d) { return d._t; }).left;
// options:
//   type -- line, sparkline, miniline
//   height -- in px, [uses ratio of 2.5]
//   ratio -- ratio of width to height [2.5]
//   width -- in px, [parent width]
//   margin -- obj, in px, {top: 30, right: 50, bottom: 30, left: 50};
//   showXAxis -- bool [default depends on type]
//   showYAxis -- bool [default depends on type]
//   xGridTicks -- count [0]
//   yGridTicks -- count [1] (depending on type)
//   scale -- linear, log [linear]
//   interactive -- bool [default depends on graph type]
//   legend -- bool [default depends on graph type]
//   yMin -- value [undef] (override minimum to show on graph)
//   yMax -- value [undef] (override maximum to show on graph)
//   yMaxSoft -- soft max y value. Uses if max Y value < yMaxSoft [undef]
//   yMaxPaddingPct -- pct padding above the max Y value
//   gradient -- obj [undef] ({low: value, high: value}, threshold for gradient. included values are 'good')
//      TODO -- specify gradient from mean value?
// TODO other options:
//       bounding ranges/series? color options? error ranges?
//   formatter -- formatting function for data
function Line(parent, options) {
  if (!(this instanceof Line)) return new Line(parent, options);
  this.parent = d3.select(parent);
  this.options = options;
  this.schema = new Schema(options);
  this.reset(options);
  EventEmitter.call(this);
}
inherits(Line, EventEmitter);

// This is a harder reset than redraw() -- it actually removes the svg element in #parent and makes a new one.
Line.prototype.reset = function (options) {
  var svgElement = this.parent.selectAll('svg');
  options = options || {};
  svgElement.remove();

  this.raw = [];
  this.series = [];
  this.timeseries = [];

  // TODO ability to change chart size upon redraw()
  this.type = 'line';
  this.parentNode = this.parent.node();
  this.width = (this.parentNode && this.parentNode.offsetWidth) || 1000;
  this.height = options.height || Math.round(this.width / DEFAULT_RATIO);
  this.selectedTime = options.selectedTime || 0;
  this.margin = options.margin || {top: 20, right: 80, bottom: 30, left: 80}; // TODO better defaults?

  this.showXAxis = true;
  this.showYAxis = true;
  this.isHoverLineEnabled = true;
  this.xGridTicks = 0;
  this.yGridTicks = 1;
  this.yAxisTicks = 10;

  this.bgfill = 'none';

  this.formatter = options.formatter;

  this.yMin = options.yMin;
  this.yMax = options.yMax;
  if (options.yMaxPaddingPct != null) {
    this.yMaxPaddingPct = (options.yMaxPaddingPct < 1) ? options.yMaxPaddingPct : options.yMaxPaddingPct / 100;
  }

  this.scale = 'linear'; // TODO other scales, e.g. log
  this.interactive = true;
  this.legend = true;

  this.color = (options.color && options.color.moduleColor) || d3.scale.category10();

  // TODO y gridlines based on data extent?

  // Now that the defaults are set, override
  this.redraw(options);

  this.innerWidth = this.width - this.margin.right - this.margin.left;
  this.innerHeight = this.height - this.margin.top - this.margin.bottom;

  this.x = d3.time.scale()
      .range([0, this.innerWidth]);

  this.y = d3.scale.linear()
      .range([this.innerHeight, 0]);
  this.y1 = d3.scale.linear()
      .range([this.innerHeight, 0]);

  this.xAxis = d3.svg.axis()
      .scale(this.x)
      .orient('bottom');

  this.xGrid = d3.svg.axis()
      .scale(this.x)
      .orient('bottom')
      .ticks(this.xGridTicks)
      .tickSize(-this.innerHeight, 0, 0)
      .tickFormat('');

  this.yAxis = this._yAxis('y');
  this.y1Axis = this._yAxis('y1');

  this.yGrid = d3.svg.axis()
      .scale(this.y)
      .orient('left')
      .ticks(this.yGridTicks)
      .tickSize(-this.innerWidth, 0, 0)
      .tickFormat('');

  this.formatDate = d3.time.format('%Y-%m-%d %H:%M:%S.%L');

  var self = this;
  this.line = d3.svg.line()
      .x(function(d) { return self.x(d.date); })
      .y(function(d) { return self[self.schema.y(d)](d.val) })
      .defined(function(d) { return (d.val != null && !isNaN(d.val)) });
  this.area = d3.svg.area()
      .x(function(d){ return self.x(d.date);})
      .y0(function(d){ return self[self.schema.y(d)](d.val.min)})
      .y1(function(d){ return self[self.schema.y(d)](d.val.max)});

  this.svg = this.parent.append('svg')
      .attr('width', this.width)
      .attr('height', this.height);

  this.graph = this.svg.append('g')
      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');

  this.graph.append('rect')
    .attr('class', 'underlay')
    .attr('width', this.innerWidth)
    .attr('height', this.innerHeight)
    //.style('fill-opacity', 0.25)
    .style('fill', this.bgfill);


};


// The initial draw of the data
Line.prototype.draw = function (data) {
  var self = this;

  if (!data || data.length === 0) {
    return new Error('No records to show.');
  }
  if (data.length > MAX_RECORDS) {
    return new Error('Too many records for Line.');
  }

  //if our width is different, hard reset
  //TODO--make resize more dynamic
  var tempwidth = (this.parentNode && this.parentNode.offsetWidth) || 4000;
  if( tempwidth != this.width ){
    this.reset(this.options);
  }
  this.raw = data;
  var series = [];
  var records = data.length;
  for (var i = 0; i < records; i++) {
    var record = data[i];
    if (series.length > MAX_SERIES) break;
    Object.keys(record).forEach(function (key) {
      if (series.length > MAX_SERIES){
        return;
      }
      if (key === '_t' || key === 'date'){
        return;
      }
      if( key === '__data'){
        return;
      }
      if (series.indexOf(key) < 0 && record[key] != null ){
        series.push(key);
      }
    });
    record.date = new Date(record._t);
  }

  if (series.length > MAX_SERIES) {
    console.log('Refusing to plot line graph with %s series', series.length);
    return new Error('Too many series detected');
  }

  var timeseries = series.map(function (name) {
      return {
        name: name,
        type: typeof record[name] == 'object' ? 'area' : 'line',
        values: data.filter(function (record) { return record[name] != null })
                    .map(function (record) { return {name: name, date: record.date, val: isNaN(record[name]) ? record[name] : +record[name]} })
      };
  });

  var yMin = (this.yMin == null) ? d3.min(timeseries.filter(function(d){ return self.schema.y(d) == 'y'}), function (s) { return d3.min(s.values, function (v) { return isNaN(v.val) ? v.val.min : v.val ; })}) : this.yMin;
  var yMax = (this.yMax == null) ? d3.max(timeseries.filter(function(d){ return self.schema.y(d) == 'y'}), function (s) { return d3.max(s.values, function (v) { return isNaN(v.val) ? v.val.max : v.val; })}) : this.yMax;

  var y1Min = (this.yMin == null) ? d3.min(timeseries.filter(function(d){ return self.schema.y(d) == 'y1'}), function (s) { return d3.min(s.values, function (v) { return isNaN(v.val) ? v.val.min : v.val ; })}) : this.yMin;
  var y1Max = (this.yMax == null) ? d3.max(timeseries.filter(function(d){ return self.schema.y(d) == 'y1'}), function (s) { return d3.max(s.values, function (v) { return isNaN(v.val) ? v.val.max : v.val; })}) : this.yMax;

  if (this.yMaxPaddingPct != null) {
    yMax = (this.yMaxPaddingPct + 1) * (yMax - yMin);
  }

  if (this.yMaxSoft != null && yMax < this.yMaxSoft) {
    yMax = this.yMaxSoft;
  }

  this.x.domain([data[0].date, data[data.length - 1].date]);
  this.y.domain([yMin, yMax]);
  this.y1.domain([y1Min, y1Max]);

  this.series = series;
  this.timeseries = timeseries;

  this._draw();

  var anomalies = self.graph.append('g')
    .attr('class', 'anomalies')
    .selectAll('path').data(data.filter(function(d, i){ return !!d.__data.lm_a }));
  anomalies.enter().append('path')
    .on('mouseover', anomalyHover)
    .on('click', anomalyClick);
  anomalies
    .attr('fill', function(d){ return d.__data.lm_a == 1 ? 'red' : '#ff7518' })
    .attr('stroke', 'none')
    .attr('d', triangle);
  anomalies.exit().remove();

  // Triangles
  function triangle(d) {
    var x = self.x(d.date);
    var y = self.innerHeight;
    var top = 'M ' + x + ' ' + (y + 3);
    var bottomLeft = 'L ' + (x - 5) + ' ' + (y + 13);
    var bottomRight = 'L ' + (x + 5) + ' ' + (y + 13);
    return top + ' ' + bottomLeft + ' ' + bottomRight + ' Z';
  }

  function anomalyHover(d) {
    self.hoverAt(d._t);
  }

  function anomalyClick(d) {
    self.emit('click', d.__data);
  }
};

// Redraw the data with different options
// Or if not drawn yet, simply set options
Line.prototype.redraw = function (options) {
  var self = this;
  // Apply type-specific defaults
  var type = options.type || this.type;
  switch (type) {
    case 'line':
      this.showXAxis = true;
      this.showYAxis = true;
      this.xGridTicks = 0;
      this.yGridTicks = 3;
      break;
    case 'miniline':
      this.showXAxis = false;
      this.showYAxis = true;
      this.xGridTicks = 0;
      this.yGridTicks = 0;
      this.yAxisTicks = 3;
      this.yTickSize = 0;
      this.margin = {top: 0, right: 0, bottom: 0, left: 35};
      this.interactive = false;
      this.legend = false;
      this.ratio = 7;
      this.bgfill = '#fff';
      this.yMaxPaddingPct = 0.1;
      break;
    case 'sparkline':
      this.showXAxis = false;
      this.showYAxis = false;
      this.xGridTicks = 0;
      this.yGridTicks = 0;
      this.yAxisTicks = 0;
      this.margin = {top: 0, right: 0, bottom: 0, left: 0};
      this.interactive = false;
      this.legend = false;
      this.ratio = 10;
      this.bgfill = '#fff';
      break;
    default:
      return new Error('Unknown chart type.');
  }
  // Simple options clobber. TBD: consider validity checks
  Object.keys(options).forEach(function (o) { self[o] = options[o] });
  if( this.color.moduleColor ) {
    this.color = this.color.moduleColor;
  }

  if (this.ratio && !options.width) {
    this.height = Math.round(this.width / this.ratio);
  }

  this.yAxis = this._yAxis();

  if (this.legend) {
    // TBD maybe make this more dynamic
    // Force 20 pixel margin at the top for the legend
    this.margin.top = 20;
  }

  // Don't attempt to re-draw if it hasn't been drawn yet (or no data)
  if (!this.timeseries.length) return;
  this._draw();
};

// New incoming data, transition in/transition out old
// Line.prototype.update = function (delta) {
//   // TODO...
// }
Line.prototype.update = Line.prototype.draw;


Line.prototype._draw = function () {
  var self = this;

  // TODO consider transitioning these out.
  this.graph.selectAll('.axis').remove();
  this.graph.selectAll('.grid').remove();
  this.graph.selectAll('.timeline').remove();
  this.graph.selectAll('#gradient').remove();
  this.graph.selectAll('.hover-line').remove();
  this.graph.selectAll('.select-line').remove();
  this.graph.selectAll('.overlay').remove();
  this.svg.selectAll('.x-legend').remove();
  this.svg.selectAll('.y-legend').remove();

  this.svg.selectAll('.underlay')
    .style('fill', this.bgfill);

  // Maybe add in some axes.
  if (this.showXAxis) {
    this.graph.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + this.innerHeight + ')')
        .call(this.xAxis);
  }

  if (this.showYAxis) {
    this.graph.append('g')
        .attr('class', 'y axis')
        .call(this.yAxis);
  }
  if( true /*this.showY1Axis*/){
    this.graph.append('g')
      .attr('class', 'y1 axis')
      .attr('transform', 'translate(' + (this.innerWidth) + ', 0)')
      .call(this.y1Axis);
  }

  if (this.yGridTicks > 0) {
    this.graph.append('g')
        .attr('class', 'y grid')
        .call(this.yGrid);
  }

  if (this.xGridTicks > 0) {
    this.graph.append('g')
        .attr('class', 'x grid')
        .attr('transform', 'translate(0,' + this.innerHeight + ')')
        .call(this.xGrid);
  }

  if (this.legend) {
    var earliest = this.raw[0]._t;
    var last = this.raw[this.raw.length - 1]._t;
    // Avg number of milli gap per record. Can be off if data is unevenly spaced.
    var avgGap = (last - earliest) / this.raw.length;
    if (avgGap > ONE_WEEK_MS) {
      this.formatDate = d3.time.format('%b %Y');
    }
    else if (avgGap > ONE_HOUR_MS * 12) {
      this.formatDate = d3.time.format('%Y-%m-%d (%a)');
    }
    else if (avgGap > ONE_MIN_MS * 30) {
      this.formatDate = d3.time.format('%Y-%m-%d (%a) %H:%M');
    }
    else if (avgGap > 1000 * 30) {
      // Bigger than 30s on average
      this.formatDate = d3.time.format('%Y-%m-%d %H:%M:%S');
    }

    // TODO checks related to total svg width

    this.xLegend = this.svg.append('g')
        .attr('class', 'x-legend')
        .attr('transform', 'translate(8, 15)');

    this.xLegend.append('text')
        .attr('class', 'legend-text');

    var nextX = 0;
    this.svg.append('g')
      .attr('class', 'y-legend')
      .attr('transform', 'translate(8, 15)')
      .selectAll('g')
      .data(this.series)
      .enter()
      .append('text')
      .attr('class', 'legend-text')
      .text(function (d) { return d; })
      .attr('x', function (d, i) {
        var offset = nextX;
        nextX += (d.length + 1) * 8;
        return offset;
      })
      .style('fill', function (d) { return self.color(d) });
  }

  switch(this.type) {
    case 'line':
    case 'miniline':
    case 'sparkline':
      return this._line();
    default:
      return new Error('Unknown chart type.');
  }


  var ts = self.selectedTime;
  if (ts) {
    var rec = self.getRecordAt(ts);
    var x = self.x(rec.date) | 0;
    self.selectionX = x;
    self.selectLine
      .attr('x1', x).attr('x2', x)
      .attr('style', 'display: visible')  ;
  }

};

Line.prototype._yAxis = function (type) {
  var axis = d3.svg.axis()
      .scale(this[type])
      .orient(type == 'y' ? 'left' : 'right');

  if (this.tickFormat) {
    axis.tickFormat(this.tickFormat);
  }
  else if (this.options.format && this.options.format[type] ) {
    axis.tickFormat(format[this.options.format[type]]);
  } else {
    axis.tickFormat(format.mb);
  }

  if (this.yAxisTicks != null) {
    axis.ticks(this.yAxisTicks);
  }

  if (this.yAxisValues != null) {
    axis.tickValues(this.yAxisValues);
  }

  if (this.yTickSize != null) {
    axis.tickSize(this.yTickSize);
  }

  return axis;
};

// Draw the loaded data as a line graph
Line.prototype._line = function () {
  var self = this;
  var draw = Draw(self);
  self.graph.selectAll('.timeline')
    .data(self.timeseries)
    .enter().append('g')
    .attr('class', 'timeline')
    .call(draw);

  if (self.interactive) {
    // TODO enable interactivity hooks/listeners
    self.hoverLineGroup = self.graph.append('g')
      .attr('class', 'hover-line');

    self.hoverLine = self.hoverLineGroup.append('line')
      // TODO x1 to 0/0, or max/max?
      .attr('x1', self.innerWidth).attr('x2', self.innerWidth)
      .attr('y1', 0).attr('y2', self.innerHeight);

    self.selectLineGroup = self.graph.append('g')
      .attr('class', 'select-line');
      //.attr('style', self.selectionX ? 'display: visible' : 'display: none')

    self.selectLine = self.selectLineGroup.append('line')
      // TODO x1 to 0/0, or max/max?
      .attr('x1', self.selectionX || self.innerWidth).attr('x2', self.selectionX || self.innerWidth)
      .attr('y1', 0).attr('y2', self.innerHeight);

    self.graph.append('rect')
      .attr('class', 'overlay')
      .attr('width', self.innerWidth)
      .attr('height', self.innerHeight)
      .on('mousemove', getHoverX)
      .on('mouseout', removeHoverX)
      .on('click', handleClick);
  }
  function handleClick(){
    var coords = d3.mouse(this)
    var ts = self.x.invert(coords[0]).getTime();
    var rec = self.getRecordAt(ts);
    var x = self.x(rec.date) | 1;
    self.selectionX = x;
    self.selectLine
      .attr('x1', x)
      .attr('x2', x)
      .attr('stroke', function (d, i) { return rec.__data.lm_a ? 'red' : 'black' })
      .attr('stroke-width', 1)
      .attr('style', 'display: visible');
    self.emit('click', rec.__data);
  }

  function removeHoverX() {
    self.hoverLine.attr('style', 'display: none');
  }
  function getHoverX() {
    var coords = d3.mouse(this);
    var ts = self.x.invert(coords[0]).getTime();
    self.hoverAt(ts);
    self.emit('hover', ts);
  }
};

Line.prototype.clearSelection = function clearSelection(){
  delete this.selectionX;
};
Line.prototype.setSelection = function setSelection(timestamp){

  var ts = timestamp;
  var rec = this.getRecordAt(ts);
  var x = this.x(rec.date) | 1;
  if (x === 0) {
    x = 1;
  }
  this.selectionX = x;
  this.hoverAt(ts);
};


Line.prototype.getRecordAt = function getRecordAt(timestamp){
  var self = this;
  var record = self.raw.slice(-1)[0];
  if (timestamp < record._t) {
    var entry = _dateBisect(self.raw, timestamp, 1);
    var left = self.raw[entry - 1];
    var right = self.raw[entry];
    if (!left || !right) {
      return right || left;
    }
    record = (timestamp - left._t > right._t - timestamp) ? right : left;
  }
  return record;
};
Line.prototype.disableHoverLine = function() {
  var self = this;
  self.isHoverLineEnabled = false;
};
Line.prototype.setSelection = function(timestamp) {
  var self = this;

  var record = self.getRecordAt(timestamp)

  // keep the line visible on first record
  var x = self.x(record.date) | 1;
  if (x === 0) {
    x = 1;
  }

  self.hoverLine
    .attr('x1', x)
    .attr('x2', x)
    .attr('stroke', function (d, i) { return record.__data.lm_a ? 'red' : 'black' })
    .attr('stroke-width', 1);

  self.selectionX = x;
  self.selectLine
    .attr('x1', x)
    .attr('x2', x)
    .attr('stroke', function (d, i) { return record.__data.lm_a ? 'red' : 'black' })
    .attr('stroke-width', 1)
    .attr('y1', 0).attr('y2', self.innerHeight)
    .attr('style', 'display: block');

  self.disableHoverLine();
};
// TODO emit/listen for highlight events when other graphs are highlighting
Line.prototype.hoverAt = function (timestamp) {
  var self = this;
  var record = self.getRecordAt(timestamp);
  var x = self.x(record.date) | 0;

  if (this.isHoverLineEnabled) {
    self.hoverLine
      .attr('x1', x)
      .attr('x2', x)
      .attr('stroke', function (d, i) {
        return record.__data.lm_a ? 'red' : 'black';
      })
      .attr('style', 'display: block')
      .attr('stroke-width', 1);
  }

  if (this.isHoverLineEnabled) {
    self.hoverLine
      .attr('x1', x)
      .attr('x2', x)
      .attr('stroke', function (d, i) {
        return record.__data.lm_a ? 'red' : 'black';
      })
      .attr('stroke-width', 1);
  }
  var formattedDate = self.formatDate(record.date);

  var colors = [];
  var legendValues = self.series.slice(0).sort(function(a, b) {
      if (record[a] == null){
        return b
      }
      if (record[b] == null) {
        return a
      }
      return record[b] - record[a]
    })
    .map(function (key) {
      var value;
      var f = self.schema.formatByKey(key);
      if( (record[key] !== undefined) && record[key] !== null) {
        if( typeof record[key] == 'object' ){
          value = [f(record[key].min), f(record[key].max)].join('/');
        } else {
          value = f(record[key]);
        }
      } else {
        value = 'N/A';
      }
      colors.push(self.color(key));
      return key + ': ' + value;
    });

  // TODO better handling when it runs off the end
  self.svg.selectAll('.y-legend')
      .attr('transform', 'translate(' + (formattedDate.length + 2) * 8 + ', 15)');
  var nextX = 0;
  self.svg.selectAll('.y-legend > .legend-text')
    .text(function (d, i) {
      return legendValues[i];
    })
    .attr('x', function (d, i) {
      var offset = nextX;
      nextX += (legendValues[i].length + 1) * 8;
      return offset;
    })
    .style('fill', function (d, i) {
      return colors[i]
    });


  self.xLegend.select('text').text(formattedDate);
};
