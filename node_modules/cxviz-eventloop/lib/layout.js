'use strict';

var d3 = require('d3')
var $ = require('jquery')

module.exports = function layoutCoords(el, expanded, data){
  var coords = {}
  coords.rowHeight = 18
  var heightMultiplier = (expanded && data) ? data.eventLoopAgg.length : 1
  coords.graphHeight = heightMultiplier * coords.rowHeight
  coords.maxEnd = (data && data.maxEnd) || 1000

  coords.contWidth = $(el).width() || 1000 //d3.select(el).node().clientWidth  (use jquery to get width without padding)
  if( $(el).width() <= 0 ){
    console.log('negative or zero width parent element', $(el).width())
  }
  coords.marginLeft = 20
  coords.marginRight = 20
  coords.marginTotal = coords.marginLeft + coords.marginRight

  if( expanded ){
    coords.graphWidth = (coords.contWidth - coords.marginRight) * 0.8
    coords.axisHeight = 30
    coords.labelWidth = coords.contWidth * 0.2
  } else {
    coords.graphWidth = coords.contWidth - coords.marginRight
    coords.axisHeight = 30
    coords.labelWidth = 0
  }

  coords.labelHeight = coords.graphHeight
  coords.overallHeight = coords.graphHeight + coords.axisHeight
  coords.overallWidth = coords.graphWidth + coords.labelWidth + coords.marginLeft
  coords.xscale = d3.scale.linear().domain([0, coords.maxEnd]).range([0,coords.graphWidth])

  // to avoid weird bugs, explicitly set the index so key matching and/or sorting does not change
  // finally, compute the layout for the graph based on whether or not we're expanded
  if( data ){
    data.eventLoopAgg.forEach(function(d,i){
      //namespace all of our modifications so we can run in parallel with other visualizations
      d.cxvEL = {
        layout: {
          width : coords.xscale(d.cost),
          x     : coords.xscale(d.start),
          y     : expanded ? (i * coords.rowHeight) : 0,
          height: coords.rowHeight
        },
        index: i
      }
    })
  }

  return coords
}
