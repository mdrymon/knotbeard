"use strict";

var d3 = require("d3")

d3.layout.flametree = function() {
  var hierarchy = d3.layout.hierarchy()
  var size = [1, 1] // width, height

  function position(node, x, dx, dy) {
    var children = node.children
    node.x = x
    node.y = node.depth * dy
    node.dx = dx
    node.dy = dy
    if (children && (n = children.length)) {
      var i = -1
      var n
      var c
      var d
      dx = node.value ? dx / node.value : 0
      while (++i < n) {
        position(c = children[i], x, d = c.value * dx, dy)
        x += d
      }
    }
  }

  function depth(node) {
    var children = node.children
    var d = 0

    if (children && (n = children.length)) {
      var i = -1
      var n
      while (++i < n) d = Math.max(d, depth(children[i]))
    }
    return 1 + d
  }

  function flametree(d, i) {
    var nodes = hierarchy.call(this, d, i)
    for (var j = 0; j < nodes.length; j++) {
      nodes[j].value = nodes[j].cost || nodes[j].childCost
    }
    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]))
    return nodes
  }

  flametree.size = function(x) {
    if (!arguments.length) return size
    size = x
    return flametree
  }

  var d3_layout_hierarchyLinks = function (nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {source: parent, target: child}
      })
    }))
  }

  // A method assignment helper for hierarchy subclasses.
  var d3_layout_hierarchyRebind = function (object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value")

    // Add an alias for nodes and links, for convenience.
    object.nodes = object
    object.links = d3_layout_hierarchyLinks

    return object
  }

  return d3_layout_hierarchyRebind(flametree, hierarchy)
}
