(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.TracingViz = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var TracingViz = angular.module('TracingViz', [])
  .value('TimeSeries', require('cxviz-timeseries'))
  .value('EventLoop', require('cxviz-eventloop'))
  .value('TraceFormat', require('cxviz-format'))
  .value('Color', require('cxviz-color'))
  .value('Sha1', require('sha1'))
  .value('FlameGraph', require('cxviz-flame'))
  .value('RawTree', require('cxviz-rawtree'))
  .value('TraceEnhance',   require('strong-trace-waterfalltransform').enhanceWaterfall)
  .value('MSFormat', require('./format').msFormat)
  .value('Inspector', require('./inspector'))
  .value('TransactionList', require('./transaction-list'));

},{"./format":2,"./inspector":3,"./transaction-list":4,"cxviz-color":15,"cxviz-eventloop":17,"cxviz-flame":28,"cxviz-format":32,"cxviz-rawtree":38,"cxviz-timeseries":41,"sha1":47,"strong-trace-waterfalltransform":48}],2:[function(require,module,exports){
'use strict'


var format = d3.format('.3s')

module.exports = {

  msFormat: function msFormat(val){
    return format(val/1000000) + 's'
  }
}

},{}],3:[function(require,module,exports){
'use strict';

var format     = require('../format');

var templates = {
}

function Inspector (options) {
  var component = this;
  var opts = component.opts = options || {};
  component.el = opts.el || document.createElement('div');
  if (opts.trace) {
    component.trace = opts.trace;
  }
  if (opts.class) {
    component.el.classList.add(opts.class);
  }

  return component;
}

Inspector.prototype.render = function render(d, trace) {
  var trace = this.trace = trace || this.trace;
  var item = d || { type: 'base' };
  var topCosts = (item.costSummary && item.costSummary.topCosts) ? item.costSummary.topCosts : undefined;
  this.el.innerHTML = '<div>world</div>';
};

Inspector.prototype.remove = function remove() {
  if (this.opts.el) this.el.innerHTML = ''
  this.opts.app.off('inspect', this.render)
};



Inspector.prototype.toggleFunction = function (e) {
  var functions = this.querySelectorAll('.top-costs .function')
  Array.prototype.forEach.call(functions, function (item) {
    var target = item.querySelector('.header')
    if (target === e.delegateTarget) return item.classList.toggle('expanded')
    item.classList.toggle('expanded', false)
  })
};

module.exports = Inspector;

},{"../format":2}],4:[function(require,module,exports){
'use strict';


var sha1       = require('sha1');
var Timeseries = require('cxviz-timeseries');
var format     = require('cxviz-format');
var path       = require('path');

var colormap = {
  'Process Heap Total': '#7777ff',
  'Process Heap Used': '#2ca02c',
  'Process RSS': '#ff7f0e',
  'stddev': '#1862b5',
  'min\/max': '#636363',
  'mean': '#1862b5',
  'number of calls': '#379f15'
};

function color(name){
  return colormap[name] || '#ff0000'
}

module.exports = TransactionList;

function TransactionList(el, app) {
  if (!(this instanceof TransactionList)) {
    return new TransactionList(el, app);
  }
  this.el  = el;
  this.app = app;
  this.history = {};
  this.transactions = [];

  // hide table header for edison: projects
  if (window.location.pathname.slice(0,13) == '/dash/edison:') {
    this.el.querySelector('header').classList.add('hidden');
  }
}

TransactionList.prototype.renderList = function renderList(keys){
  var self = this;
  keys = keys || [];
  var sel = d3.select(this.el).selectAll('.transaction').data(keys);

  sel.enter().append('li')
    .attr('id', function(d){ return 'cx-mv-transaction-' + sha1(d)})
    .attr('data-id', function (d) { return sha1(d) })
    .attr('class', 'list-group-item transaction')
    .each(function(){

      enterTransactionStats(this);
      this.timeseriesGraph = setupTimeseries(this);

      this.timeseriesGraph.on('click',function (e) {

        var scope = angular.element($("#TracingTransactionHistoryContainer")).scope();
        scope.$apply(function(){
          scope.updatePFKeyFromTransactionHistory(e.pfkey);
        });
      });
    })
    .select('svg')
      .attr('data-id', function(d){ return sha1(d) })
    .attr('class', 'viz');
  sel.exit().remove();
};

TransactionList.prototype.renderItem = function renderItem(key, history){
  var isEdison = false;
  var data = toTimeseries(history, isEdison);
  var reduced = history.reduce(function(prev, curr){
    return prev + curr.mean
  }, 0);
  var averageMean = reduced / history.length;
  this.history[key] = history;
  d3.select('#cx-mv-transaction-'+ sha1(key))
    .each(function() {
      d3.select(this).select('.transaction-average-mean ')
        .text( isEdison ? format.num(averageMean):format.ms(averageMean));
      return this.timeseriesGraph.draw(data);
    });
};

TransactionList.prototype.render = function (transactions) {
  var self = this;
  this.transactions = transactions || this.transactions; // new transaction structure
  var keys = [];
  this.transactions.map(function(transaction) {
    keys.push(transaction.key);
  });
  self.renderList(keys);
  this.transactions.forEach(function (transaction) {
    if (transaction.history) {
      self.renderItem(transaction.key, transaction.history);
    }
  });
};

function toTimeseries(history, isEdison){

  var ret = history.map(function(d){
    var item = {
      __data: d,
      _t: moment(d.ts).unix()*1000,
      'stddev': {
        min: d.mean - d.sd,
        max: d.mean + d.sd
      },
      'min/max': {
        min: d.min,
        max: d.max
      },
      'mean': d.mean,
      'number of calls': d.n
    };

    return item;
  });
  return ret.sort(function(a,b){ return a._t - b._t;});
}

function setupTimeseries(el){
  var isEdison = false;
  var options = {
    yMin: 0,
    color: color,
    format: {
      'y': isEdison ? 'num':'ms',
      'y1': 'num'
    },
    keySchema: {
      'stddev': {
        class: 'cx-monitor-stddev',
        type: 'rect'
      },
      'min/max': {
        class: 'cx-monitor-minmax',
        type: 'range'
      },
      'number of calls': {
        y: 'y1',
        class: 'cx-monitor-numcalls'
      },
      'mean': {
        class: 'cx-monitor-mean',
        'y': 'y',
        type: 'line'
      }
    }
  };

  return Timeseries(el, options);
}

function enterTransactionStats(el) {
  var transactionStatsEnter = d3.select(el);
  var transactionStatsTableEnter = transactionStatsEnter.append('table')
    .on('click', function(d,i) {
      jQuery('svg[data-id="' + sha1(d) + '"]').toggle(400);
    });

  var transactionStatsRowEnter = transactionStatsTableEnter.append('tr');
  transactionStatsRowEnter.append('td')
    .attr('class', 'transaction-route')
    .text(function(d){ return d });
  transactionStatsRowEnter.append('td')
    .attr('class', 'transaction-average-mean');
}

},{"cxviz-format":32,"cxviz-timeseries":41,"path":11,"sha1":47}],5:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":6,"ieee754":7,"is-array":8}],6:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],7:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],8:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],9:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],10:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],11:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":12}],12:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],13:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],14:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":13,"_process":12,"inherits":10}],15:[function(require,module,exports){
'use strict';

var randomcolor = require('randomcolor')
var cache = {}

//TODO for now just return a cached color.  in the future we will use pre-determined colors for popular modules
//as well as categories like database modules

module.exports.moduleColor = function moduleColor(mod){
  cache[mod] = cache[mod] || randomcolor()
  return cache[mod]
}

},{"randomcolor":16}],16:[function(require,module,exports){
;(function(root, factory) {

  // Support AMD
  if (typeof define === 'function' && define.amd) {
    define([], factory);

  // Support CommonJS
  } else if (typeof exports === 'object') {
    var randomColor = factory();
    
    // Support NodeJS & Component, which allow module.exports to be a function
    if (typeof module === 'object' && module && module.exports) {
      exports = module.exports = randomColor;
    }
    
    // Support CommonJS 1.1.1 spec
    exports.randomColor = randomColor;
  
  // Support vanilla script loading
  } else {
    root.randomColor = factory();
  };

}(this, function() {

  // Shared color dictionary
  var colorDictionary = {};

  // Populate the color dictionary
  loadColorBounds();

  var randomColor = function(options) {
    options = options || {};

    var H,S,B;

    // Check if we need to generate multiple colors
    if (options.count) {

      var totalColors = options.count,
          colors = [];

      options.count = false;

      while (totalColors > colors.length) {
        colors.push(randomColor(options));
      }

      return colors;
    }

    // First we pick a hue (H)
    H = pickHue(options);

    // Then use H to determine saturation (S)
    S = pickSaturation(H, options);

    // Then use S and H to determine brightness (B).
    B = pickBrightness(H, S, options);

    // Then we return the HSB color in the desired format
    return setFormat([H,S,B], options);
  };

  function pickHue (options) {

    var hueRange = getHueRange(options.hue),
        hue = randomWithin(hueRange);

    // Instead of storing red as two seperate ranges,
    // we group them, using negative numbers
    if (hue < 0) {hue = 360 + hue}

    return hue;

  }

  function pickSaturation (hue, options) {

    if (options.luminosity === 'random') {
      return randomWithin([0,100]);
    }

    if (options.hue === 'monochrome') {
      return 0;
    }

    var saturationRange = getSaturationRange(hue);

    var sMin = saturationRange[0],
        sMax = saturationRange[1];

    switch (options.luminosity) {

      case 'bright':
        sMin = 55;
        break;

      case 'dark':
        sMin = sMax - 10;
        break;

      case 'light':
        sMax = 55;
        break;
   }

    return randomWithin([sMin, sMax]);

  }

  function pickBrightness (H, S, options) {

    var brightness,
        bMin = getMinimumBrightness(H, S),
        bMax = 100;

    switch (options.luminosity) {

      case 'dark':
        bMax = bMin + 20;
        break;

      case 'light':
        bMin = (bMax + bMin)/2;
        break;

      case 'random':
        bMin = 0;
        bMax = 100;
        break;
    }

    return randomWithin([bMin, bMax]);

  }

  function setFormat (hsv, options) {

    switch (options.format) {

      case 'hsvArray':
        return hsv;

      case 'hsv':
        return colorString('hsv', hsv);

      case 'rgbArray':
        return HSVtoRGB(hsv);

      case 'rgb':
        return colorString('rgb', HSVtoRGB(hsv));

      default:
        return HSVtoHex(hsv);
    }

  }

  function getMinimumBrightness(H, S) {

    var lowerBounds = getColorInfo(H).lowerBounds;

    for (var i = 0; i < lowerBounds.length - 1; i++) {

      var s1 = lowerBounds[i][0],
          v1 = lowerBounds[i][1];

      var s2 = lowerBounds[i+1][0],
          v2 = lowerBounds[i+1][1];

      if (S >= s1 && S <= s2) {

         var m = (v2 - v1)/(s2 - s1),
             b = v1 - m*s1;

         return m*S + b;
      }

    }

    return 0;
  }

  function getHueRange (colorInput) {

    if (typeof parseInt(colorInput) === 'number') {

      var number = parseInt(colorInput);

      if (number < 360 && number > 0) {
        return [number, number];
      }

    }

    if (typeof colorInput === 'string') {

      if (colorDictionary[colorInput]) {
        var color = colorDictionary[colorInput];
        if (color.hueRange) {return color.hueRange}
      }
    }

    return [0,360];

  }

  function getSaturationRange (hue) {
    return getColorInfo(hue).saturationRange;
  }

  function getColorInfo (hue) {

    // Maps red colors to make picking hue easier
    if (hue >= 334 && hue <= 360) {
      hue-= 360;
    }

    for (var colorName in colorDictionary) {
       var color = colorDictionary[colorName];
       if (color.hueRange &&
           hue >= color.hueRange[0] &&
           hue <= color.hueRange[1]) {
          return colorDictionary[colorName];
       }
    } return 'Color not found';
  }

  function randomWithin (range) {
    return Math.floor(range[0] + Math.random()*(range[1] + 1 - range[0]));
  }

  function shiftHue (h, degrees) {
    return (h + degrees)%360;
  }

  function HSVtoHex (hsv){

    var rgb = HSVtoRGB(hsv);

    function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    }

    var hex = "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);

    return hex;

  }

  function defineColor (name, hueRange, lowerBounds) {

    var sMin = lowerBounds[0][0],
        sMax = lowerBounds[lowerBounds.length - 1][0],

        bMin = lowerBounds[lowerBounds.length - 1][1],
        bMax = lowerBounds[0][1];

    colorDictionary[name] = {
      hueRange: hueRange,
      lowerBounds: lowerBounds,
      saturationRange: [sMin, sMax],
      brightnessRange: [bMin, bMax]
    };

  }

  function loadColorBounds () {

    defineColor(
      'monochrome',
      null,
      [[0,0],[100,0]]
    );

    defineColor(
      'red',
      [-26,18],
      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]
    );

    defineColor(
      'orange',
      [19,46],
      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]
    );

    defineColor(
      'yellow',
      [47,62],
      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]
    );

    defineColor(
      'green',
      [63,158],
      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]
    );

    defineColor(
      'blue',
      [159, 257],
      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]
    );

    defineColor(
      'purple',
      [258, 282],
      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]
    );

    defineColor(
      'pink',
      [283, 334],
      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]
    );

  }

  function HSVtoRGB (hsv) {

    // this doesn't work for the values of 0 and 360
    // here's the hacky fix
    var h = hsv[0];
    if (h === 0) {h = 1}
    if (h === 360) {h = 359}

    // Rebase the h,s,v values
    h = h/360;
    var s = hsv[1]/100,
        v = hsv[2]/100;

    var h_i = Math.floor(h*6),
      f = h * 6 - h_i,
      p = v * (1 - s),
      q = v * (1 - f*s),
      t = v * (1 - (1 - f)*s),
      r = 256,
      g = 256,
      b = 256;

    switch(h_i) {
      case 0: r = v, g = t, b = p;  break;
      case 1: r = q, g = v, b = p;  break;
      case 2: r = p, g = v, b = t;  break;
      case 3: r = p, g = q, b = v;  break;
      case 4: r = t, g = p, b = v;  break;
      case 5: r = v, g = p, b = q;  break;
    }
    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];
    return result;
  }

  function colorString (prefix, values) {
    return prefix + '(' + values.join(', ') + ')';
  }

  return randomColor;
}));
},{}],17:[function(require,module,exports){
'use strict';

/**
 * Dependencies
 */

var d3      = require('d3')
var Work    = require('./lib/work')
var Wait    = require('./lib/wait')
var Label   = require('./lib/label')
var Row     = require('./lib/row')
var Emitter = require('component-emitter')
var layout  = require('./lib/layout')
var color   = require('cxviz-color')


/**
 * Waterfall Constructor
 *
 * @return {Waterfall}
 * @public
 */

function EventLoopViz () {
  if (!(this instanceof EventLoopViz)) return new EventLoopViz()
  return this
}

Emitter(EventLoopViz.prototype)


/**
 * Init
 *
 * @param {Element} el
 * @param {Object} options
 * @public
 */

EventLoopViz.prototype.init = function (el, options) {
  // Options
  var opts = this.opts = options || {}
  opts.rowHeight = opts.rowHeight || 30
  opts.expanded = opts.expanded || false
  this.color = opts.color || color
  this.el = el
  this.coords = layout(el, opts.expanded)
  this.width = d3.select(el).attr('width')
  this.svg = d3.select(el)
    .append('svg')
    .attr('width', '100%')
    .attr('height', '100%')
    .attr('class', 'cxviz-eventloop')
    .attr('preserveAspectRatio', 'none')

  this.margin = this.svg.append('g')
    .attr('class', 'cxviz-eventloop-margin')
  this.axisCont = this.margin.append('g')
    .attr('class', 'cxviz-eventloop-axis')
  this.graphCont = this.margin.append('g')
    .attr('class', 'cxviz-eventloop-graphCont')
  this.labelCont = this.margin.append('g')
    .attr('class', 'cxviz-eventloop-labelCont')
  this.labelCont.append('clipPath')
    .attr('id', 'cxviz-eventloop-labelclip')
    .append('rect')
      .attr('class', 'clip-path-rect')
      .attr('x', 0)
      .attr('y', 0)
  this.rowCont = this.margin.append('g')
    .attr('class', 'cxviz-eventloop-rowCont')

  this.wait  = new Wait(this)
  this.work  = new Work(this)
  this.label = new Label(this)
  this.row   = new Row(this)
  return this
}


/**
 * Update
 *
 * @param {Array} data
 * @public
 */

EventLoopViz.prototype.update  = function (data, fns) {
  var self = this
  this.fns = fns
  this.lastData = data
  this.coords = layout(this.el, this.opts.expanded, data)
  this.layoutGraph()

  //this.svg.attr('viewBox', ['0', '0', this.coords.overallWidth, this.coords.overallHeight].join(' ') )
  this.work.updateSel(this.graphCont, this.opts.expanded, data)
  this.wait.updateSel(this.graphCont, this.opts.expanded, data)
  if( self.opts.expanded ){
    this.row.updateSel(this.rowCont, this.opts.expanded, data)
    this.label.updateSel(this.labelCont, data)


  } else {
    this.label.clearSel(this.labelCont)
    this.row.clearSel(this.svg)
  }
  // axis -- always draw this
  var axis = d3.svg.axis()
    .scale(self.coords.xscale)
    .orient('bottom')
    .tickFormat(msFormat)

  self.axisCont.call(axis)

}

EventLoopViz.prototype.resize = function resize() {
  if (!this.lastData) return
  this.update(this.lastData)
}


/**
 * setActive
 *
 * @param {Type} name
 * @return {Type}
 * @public
 */

EventLoopViz.prototype.setActive = function() {

}


/**
 * setInactive
 *
 * @param {Type} name
 * @return {Type}
 * @public
 */

EventLoopViz.prototype.setInactive = function() {

}


EventLoopViz.prototype.expand = function (state) {
  if (typeof state === 'undefined') state = !this.opts.expanded
  this.opts.expanded = state
  this.update(this.data)
}

EventLoopViz.prototype.layoutGraph = function layoutGraph(){
  this.svg
    .attr('height', this.coords.overallHeight)
    .attr('width', this.coords.overallWidth)
  this.margin
    .attr('transform', 'translate(' + [this.coords.marginLeft, 0] + ')')
  this.axisCont
    .attr('transform', 'translate(' + [this.coords.labelWidth, 0] + ')')
  this.graphCont
    .attr('transform', 'translate(' + [this.coords.labelWidth, this.coords.axisHeight] + ')')
  this.labelCont
    .attr('transform', 'translate(' + [0, this.coords.axisHeight] + ')')
  this.rowCont
    .attr('transform', 'translate(' + [0, this.coords.axisHeight] + ')')

  //now adjust the label container cliprect
  this.labelCont.select('rect.clip-path-rect')
    .attr('height', this.coords.overallHeight - this.coords.axisHeight)
    .attr('width', this.coords.labelWidth)
}

EventLoopViz.prototype.highlight = function(data) {
  this.row.highlight(data)
}

EventLoopViz.prototype.select = function(data) {
  this.row.select(data)
}


var format = d3.format('.3s')

function msFormat(d){
  return format(d/1000000) + 's'
}

/**
 * Exports
 */

module.exports = EventLoopViz

},{"./lib/label":19,"./lib/layout":20,"./lib/row":21,"./lib/wait":22,"./lib/work":23,"component-emitter":24,"cxviz-color":25,"d3":"d3"}],18:[function(require,module,exports){
'use strict';

//use a syntetically generated id if available for uniqueness, the id otherwise
module.exports = function key(d){
  return d.uid || d.id
}

},{}],19:[function(require,module,exports){
'use strict';

var d3  = require('d3')
var key = require('./key')

function Label (viz) {
  if (!(this instanceof Label)){
    return new Label(viz)
  }
  this.viz = viz
}

Label.prototype.updateSel = function updateSel(sel, data){
  var self = this
  var update = sel.selectAll('.cxviz-eventloop-label').data(data.eventLoopAgg, key)
  update.enter().append('text')
    .attr('class', 'cxviz-eventloop-label')
    .attr('clip-path', 'url(#cxviz-eventloop-labelclip)')
    .attr('id', function(d){ return 'cxviz-eventloop-label-text-' + key(d)})

  update.attr('x', 0)
    .attr('y', function(d){ return d.cxvEL.index * self.viz.coords.rowHeight})
    .attr('dx', 0)
    .attr('dy', (2 * self.viz.coords.rowHeight) / 3)
    .text(labelText)
  update.exit().remove()
}

Label.prototype.clearSel = function clearSel(sel){
  sel.selectAll('.cxviz-eventloop-label').remove()
}

Label.prototype.expandLabel = function expandLabel(d){
  var sel = this.viz.labelCont
  sel.select('#cxviz-eventloop-label-text-' + key(d))
    .attr('clip-path', null)
}

Label.prototype.clipLabel = function clipLabel(d){
  var sel = this.viz.labelCont
  sel.select('#cxviz-eventloop-label-text-' + key(d))
    .attr('clip-path', 'url(#cxviz-eventloop-labelclip)')
}

Label.prototype.clipAllLabels = function clipAllLabels(){
  var sel = this.viz.labelCont
  sel.selectAll('.cxviz-eventloop-label')
    .attr('clip-path', 'url(#cxviz-eventloop-labelclip)')
}
function labelText(d){
  var label = (d.type == 'fn') ? 'sync: ' : 'async: '
  return label += ((d.costSummary && d.costSummary.summaryText) || d.name)
}



module.exports = Label

},{"./key":18,"d3":"d3"}],20:[function(require,module,exports){
'use strict';

var d3 = require('d3')
var $ = require('jquery')

module.exports = function layoutCoords(el, expanded, data){
  var coords = {}
  coords.rowHeight = 18
  var heightMultiplier = (expanded && data) ? data.eventLoopAgg.length : 1
  coords.graphHeight = heightMultiplier * coords.rowHeight
  coords.maxEnd = (data && data.maxEnd) || 1000

  coords.contWidth = $(el).width() || 1000 //d3.select(el).node().clientWidth  (use jquery to get width without padding)
  if( $(el).width() <= 0 ){
    console.log('negative or zero width parent element', $(el).width())
  }
  coords.marginLeft = 20
  coords.marginRight = 20
  coords.marginTotal = coords.marginLeft + coords.marginRight

  if( expanded ){
    coords.graphWidth = (coords.contWidth - coords.marginRight) * 0.8
    coords.axisHeight = 30
    coords.labelWidth = coords.contWidth * 0.2
  } else {
    coords.graphWidth = coords.contWidth - coords.marginRight
    coords.axisHeight = 30
    coords.labelWidth = 0
  }

  coords.labelHeight = coords.graphHeight
  coords.overallHeight = coords.graphHeight + coords.axisHeight
  coords.overallWidth = coords.graphWidth + coords.labelWidth + coords.marginLeft
  coords.xscale = d3.scale.linear().domain([0, coords.maxEnd]).range([0,coords.graphWidth])

  // to avoid weird bugs, explicitly set the index so key matching and/or sorting does not change
  // finally, compute the layout for the graph based on whether or not we're expanded
  if( data ){
    data.eventLoopAgg.forEach(function(d,i){
      //namespace all of our modifications so we can run in parallel with other visualizations
      d.cxvEL = {
        layout: {
          width : coords.xscale(d.cost),
          x     : coords.xscale(d.start),
          y     : expanded ? (i * coords.rowHeight) : 0,
          height: coords.rowHeight
        },
        index: i
      }
    })
  }

  return coords
}

},{"d3":"d3","jquery":"jquery"}],21:[function(require,module,exports){
'use strict';

var key = require('./key')
var d3  = require('d3')

function Row (viz) {
  if (!(this instanceof Row)){
    return new Row(viz)
  }
  this.viz = viz
}

Row.prototype.updateSel = function updateSel(sel, expanded, data){
  var self = this
  var update = sel.selectAll('.cxviz-eventloop-row').data(data.eventLoopAgg, key)
  update.enter().append('rect')
    .attr('class', 'cxviz-eventloop-row')
    .on('mouseenter', function(d){ self.mouseEnter(d3.select(this), d)})
    .on('mouseleave', function(d){ self.mouseLeave(d3.select(this), d)})
    .on('click', function(d){ self.click(d3.select(this), d)})

  update.attr('width', this.viz.coords.overallWidth)
    .attr('height', function(d){ return d.cxvEL.layout.height })
    .attr('x', 0)
    .attr('y', function (d) { return d.cxvEL.layout.y })

  update.exit().remove()
}

Row.prototype.clearSel = function clearSel(sel){
  sel.selectAll('.cxviz-eventloop-row').remove()
}


Row.prototype.mouseEnter = function mouseEnter(sel, d){
  this.viz.emit('mouseenter', {
    type: "eventLoop",
    item: d
  })
}

Row.prototype.mouseLeave = function mouseLeave(sel, d){
  this.viz.emit('mouseleave', {
    type: 'eventLoop',
    item: d
  })
}

Row.prototype.click = function click(sel, d){
  this.viz.emit('click', {
    type: 'eventLoop',
    item: d
  })
}

Row.prototype.highlight = function (data) {
  var self = this
  var sel = d3.select(this.viz.el).selectAll('.cxviz-eventloop-row')
  sel.each(function (item) {
    var el = d3.select(this)
    var label = self.viz.label
    var result = (data === item)
    if (el.classed('cxviz-eventloop-selected')) return
    result ? label.expandLabel(item) : label.clipLabel(item)
    el.classed('cxviz-eventloop-highlight', result)
  })
}

Row.prototype.select = function (data) {
  var self = this
  var sel = d3.select(this.viz.el).selectAll('.cxviz-eventloop-row')
  this.viz.label.clipAllLabels()
  this.viz.label.expandLabel(data)
  sel.each(function (item) {
    var label = self.viz.label
    var result = (data === item)
    result ? label.expandLabel(item) : label.clipLabel(item)
    d3.select(this).classed('cxviz-eventloop-selected', result)
  })
}

Row.prototype.clearSelection = function clearSelection(){
  this.viz.svg.selectAll('.cxviz-eventloop-selected')
    .classed('cxviz-eventloop-selected', false)
    .each(function(d){ d.selected = false })
  this.viz.label.clipAllLabels()
}

module.exports = Row

},{"./key":18,"d3":"d3"}],22:[function(require,module,exports){
"use strict";

module.exports = Wait

var d3 = require('d3')
var key     = require('./key')

function Wait(viz) {
  if (!(this instanceof Wait)) {
    return new Wait(viz)
  }
  this.viz = viz
}

Wait.prototype.updateSel = function updateSel(sel, expanded, data){
  var self = this
  var wait = data.eventLoopAgg.filter(function(d){ return d.type != 'fn'})
  var update = sel.selectAll('.cxviz-eventloop-wait-item').data(wait, key)
  var path = d3.svg.line()
    .x(function(d){ return d.x})
    .y(function(d){ return d.y})
    .interpolate('linear')

  update.enter().append('path')
    .attr('class', 'cxviz-eventloop-wait-item')

  update.attr('d', function(d) { return path(pathCoords(d)) })
    .attr('fill', 'none')
    .attr('stroke', 'blue')
    .attr('stroke-width', '1px')


  update.exit().remove()


  function pathCoords(d){
    var coords = []
    var start = {
      x: d.cxvEL.layout.x,
      y: expanded ? d.cxvEL.layout.y - 2 : d.cxvEL.layout.height / 2
    }
    coords.push(start)

    var midLeft = {
      x: start.x,
      y: expanded ? start.y + (self.viz.coords.rowHeight / 2) : start.y + 7
    }
    coords.push(midLeft)

    var mid = {
      x: start.x + (d.cxvEL.layout.width / 2),
      y: midLeft.y
    }
    coords.push(mid)

    var midRight = {
      x: start.x + d.cxvEL.layout.width,
      y: mid.y
    }
    coords.push(midRight)

    var end = {
      x: midRight.x,
      y: expanded ? start.y + self.viz.coords.rowHeight + 3 : start.y
    }
    coords.push(end)

    return coords
  }
}

},{"./key":18,"d3":"d3"}],23:[function(require,module,exports){
'use strict';

var d3  = require('d3')
var key = require('./key')

function Work (viz) {
  if (!(this instanceof Work)){
    return new Work(viz)
  }
  this.viz = viz
}

Work.prototype.updateSel = function updateSel(sel, expanded, data){
  var self = this
  var work = data.eventLoopAgg.filter(function(d){ return d.type == 'fn'})
  var update = sel.selectAll('.cxviz-eventloop-work-item').data(work, key)
  update.enter().append('rect')
    .attr('class', 'cxviz-eventloop-work-item')

  update.attr('width', function(d) { if( d.cxvEL.layout.width < 0) { return 0;} return d.cxvEL.layout.width })
    .attr('height', function(d){ return expanded ? d.cxvEL.layout.height - 4 : (d.cxvEL.layout.height / 2) -2 })
    .attr('fill', function(d) { return self.viz.color.moduleColor(d.costSummary.topMods[0].name) })
    .attr('stroke', function(d){ return d3.rgb(self.viz.color.moduleColor(d.costSummary.topMods[0].name)).darker()})
    .attr('stroke-width', '1px')
    .attr('x', function (d) { return d.cxvEL.layout.x})
    .attr('y', function (d) { return d.cxvEL.layout.y + 2 })

  update.exit().remove()
}

module.exports = Work

},{"./key":18,"d3":"d3"}],24:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],25:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"randomcolor":26}],26:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],27:[function(require,module,exports){
"use strict";

var d3 = require("d3")

d3.layout.flametree = function() {
  var hierarchy = d3.layout.hierarchy()
  var size = [1, 1] // width, height

  function position(node, x, dx, dy) {
    var children = node.children
    node.x = x
    node.y = node.depth * dy
    node.dx = dx
    node.dy = dy
    if (children && (n = children.length)) {
      var i = -1
      var n
      var c
      var d
      dx = node.value ? dx / node.value : 0
      while (++i < n) {
        position(c = children[i], x, d = c.value * dx, dy)
        x += d
      }
    }
  }

  function depth(node) {
    var children = node.children
    var d = 0

    if (children && (n = children.length)) {
      var i = -1
      var n
      while (++i < n) d = Math.max(d, depth(children[i]))
    }
    return 1 + d
  }

  function flametree(d, i) {
    var nodes = hierarchy.call(this, d, i)
    for (var j = 0; j < nodes.length; j++) {
      nodes[j].value = nodes[j].cost || nodes[j].childCost
    }
    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]))
    return nodes
  }

  flametree.size = function(x) {
    if (!arguments.length) return size
    size = x
    return flametree
  }

  var d3_layout_hierarchyLinks = function (nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {source: parent, target: child}
      })
    }))
  }

  // A method assignment helper for hierarchy subclasses.
  var d3_layout_hierarchyRebind = function (object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value")

    // Add an alias for nodes and links, for convenience.
    object.nodes = object
    object.links = d3_layout_hierarchyLinks

    return object
  }

  return d3_layout_hierarchyRebind(flametree, hierarchy)
}

},{"d3":"d3"}],28:[function(require,module,exports){
'use strict';

var d3                              = require('d3')
var $                               = require('jquery')
var color                           = require('cxviz-color')
var Emitter                         = require('component-emitter')
var flameid                         = 0
var format                          = require('cxviz-format')

require("./flametree") // mutates d3

function FlameGraph() {
  if (!(this instanceof FlameGraph)) return new FlameGraph()
  return this
}

Emitter(FlameGraph.prototype)

//exported functions

FlameGraph.prototype.init = function init(element, options) {
  var self = this
  this.width = 1000
  this.height = 1000
  this.cb = options && options.cb
  this.color = (options && options.cb) || color
  this.el = element
  this.scale = 1
  this.zoomEnabled = !(options.disableZoom)
  this.flameid = flameid++

  this.svg = d3.select(element).append('svg')
    .attr('class', 'cxviz-flame')

  this.zoom = d3.behavior.zoom()
    .scaleExtent([0.4, 100])
    .on('zoom', handleZoom)

  this.parentGroup = this.svg.append('g')
    .call(this.zoomEnabled ? this.zoom : function(){return this})

  this.zoomRect = this.parentGroup.append('rect')
    .style('fill', 'none') // TODO css
    .attr('pointer-events', this.zoomEnabled ? 'all' : 'auto')
    .attr('width', '100%')
    .attr('height', '100%')

  this.margin   = this.parentGroup.append('g')
  this.zoomCont = this.margin.append('g')
  this.plot     = this.zoomCont.append('g')

  this.axisCont = this.zoomCont.append('g')
    .attr('class', 'cxviz-flame-axis')

  function handleZoom() {
    if( self.zoomEnabled ){
      self.scale = d3.event.scale
      self.zoomCont.attr('transform', 'translate(' + [d3.event.translate[0], 0] + ')')
      if( self.lastData ){
        self.update(self.lastData, self.lastFunctions)
      }
    }
  }

  return this
}

FlameGraph.prototype.setActive = function setActive(){
  //set ourselves to the zoomControl
  this.cb.zoomControl.setZoom(this.zoom)
  this.cb.zoomControl.show()
}

FlameGraph.prototype.setInactive = function setInactive(){
  this.cb.zoomControl.hide()
}

FlameGraph.prototype.resize = function resize() {
  if (!this.lastData) return
  this.update(this.lastData, this.lastFunctions)
}

FlameGraph.prototype.update = function update(data, functions) {
  var self = this
  this.lastData = data
  this.lastFunctions = functions
  this.coords = this.layoutCoords(this.el, data)
  this.layoutGraph()
  var x = this.coords.xscale
  var y = this.coords.yscale

  var vis = this.plot

  // Map each name to its bucket.
  var flametree = d3.layout.flametree()
    .value(function(d) {
      return d.cost
    })

  var p = flametree(data.costTree)

  var sel = vis.selectAll('.cxviz-flame-item')
    .data(p, function key(d){ return d.uid })

  var g = sel.enter()
    .append('g')
    .attr("clip-path", function(d){ return 'url(#' + self.getClipId(d) + ')' })
    .attr('class', 'cxviz-flame-item')

  g.append("title")
      .text(nodeText)

  g.append('svg:rect')
    .attr('x', function(d) {
      return x(d.x)
    })
    .attr('y', function(d) {
      return y(1.0 - d.y)
    })
    .attr('width', function(d) {
      return x(d.dx)
    })
    .attr('height', function(d) {
      return y(d.dy)
    })
    .attr('stroke', strokeColor)
    .attr('fill', modColor)
    .on('mouseenter', function(d){ self.mouseEnter(d3.select(this), d)})
    .on('mouseleave', function(d){ self.mouseLeave(d3.select(this), d)})
    .on('click', function(d){ self.click(d3.select(this), d)})
  g.append("clipPath")
      .attr("id", function(d){return self.getClipId(d)})
    .append("rect")
      .attr("class", "clipPathRect")
      .attr("y", function(d) { return y(1.0 - d.y) })
      .attr("height", function(d){ return y(d.dy)})
      .attr("x", function(d) { return x(d.x) })
      .attr("width", function(d) { return x(d.dx) })

  g.append('text')
    .on('mouseenter', function(d){ self.mouseEnter(d3.select(this), d)})
    .on('mouseleave', function(d){ self.mouseLeave(d3.select(this), d)})
    .on('click', function(d){ self.click(d3.select(this), d)})
    .attr('x', function(d) {
      return x(d.x)
    })
    .attr('y', function(d) {
      return y((1.0 - d.y) + d.dy / 2)
    })
    .attr('dx', '6') // margin
    .attr('dy', '.35em') // vertical-align
    .text(nodeText)

  sel.select('title')
    .text(nodeText)

  sel.select('rect')
     .attr('x', function(d) {
      return x(d.x)
    })
    .attr('y', function(d) {
      return y(1.0 - d.y)
    })
    .attr('width', function(d) {
      return x(d.dx)
    })
    .attr('height', function(d) {
      return y(d.dy)
    })
    .attr('stroke', strokeColor)
    .attr('fill', modColor)

  sel.select('.clipPathRect')
      .attr("y", function(d) { return y(1.0 - d.y) })
      .attr("height", function(d){ return y(d.dy)})
      .attr("x", function(d) { return x(d.x) })
      .attr("width", function(d) { return x(d.dx) })

  sel.select('text')
    .attr('x', function(d) {
      return x(d.x)
    })
    .attr('y', function(d) {
      return y((1.0 - d.y) + d.dy / 2)
    })
    .attr('dx', '6') // margin
    .attr('dy', '.35em') // vertical-align
    .text(nodeText)

  sel.exit()
    .remove()

  //now handle the axis
    // axis -- always draw this
  var axis = d3.svg.axis()
    .scale(d3.scale.linear().domain([0, 100]).range(self.coords.xscale.range()))
    .orient('bottom')
    .tickFormat(percentFormat)

  self.axisCont.call(axis)

  self.modColor = modColor

  function modColor(d){
    return self.color.moduleColor(getModName(d))
  }

  function strokeColor(d){
    return d3.rgb(modColor(d)).darker()
  }

  function nodeText(d){
    return d.name
  }
  function getModName(d){
    var fn = functions[d.id]
    return fn && fn.module && (fn.module.name || fn.module.filename)
  }
}

FlameGraph.prototype.layoutGraph = function layoutGraph(){
  this.svg
    .attr('height', this.coords.overallHeight)
    .attr('width', this.coords.overallWidth)
  this.margin
    .attr('transform', 'translate(' + [this.coords.marginLeft, 0] + ')')
  this.axisCont
    .attr('transform', 'translate(' + [0, this.coords.graphHeight + this.coords.rowHeight + this.coords.axisSpacing] + ')')
}

FlameGraph.prototype.layoutCoords = function layoutCoords(el, data){
  var coords = {}
  coords.rowHeight = 18
  coords.axisHeight = 30
  coords.marginLeft = 20
  coords.marginRight = 20
  coords.axisSpacing = 5
  var heightMultiplier = data.maxDepth + 3
  coords.graphHeight = heightMultiplier * coords.rowHeight
  coords.maxEnd = data.costTree.childCost

  coords.contWidth = $(el).width() || 1000 //(use jquery to get width without padding)
  if( $(el).width() <= 0 ){
    console.log('negative or zero width parent element', $(el).width())
  }
  coords.graphWidth    = coords.contWidth - coords.marginLeft - coords.marginRight
  coords.overallHeight = coords.graphHeight + coords.axisHeight + coords.rowHeight + coords.axisSpacing  //TODO--we have an off by 1 error on rowHeight somehwo
  coords.overallWidth  = coords.contWidth

  coords.xscale = d3.scale.linear().range([0,coords.graphWidth * this.scale])
  coords.yscale = d3.scale.linear().range([0,coords.graphHeight])

  return coords
}

FlameGraph.prototype.mouseEnter = function mouseEnter(sel, d){
  this.emit('mouseenter', {
    type: "flame",
    item: d
  })
}

FlameGraph.prototype.mouseLeave = function mouseLeave(sel, d){
  this.emit('mouseleave', {
    type: 'flame',
    item: d
  })
}

FlameGraph.prototype.click = function click(sel, d){
  this.emit('click', {
    type: 'flame',
    item: d
  })
}

FlameGraph.prototype.highlight = function (data) {
  var sel = d3.select(this.el).selectAll('.cxviz-flame-item')
  sel.each(function (item) {
    d3.select(this).classed('cxviz-flame-highlight', function(d){
      return data === d
    })
  })
}

FlameGraph.prototype.select = function (data) {
  var sel = d3.select(this.el).selectAll('.cxviz-flame-item')
  sel.each(function (item) {
    d3.select(this).classed('cxviz-flame-selected', function(d){
      return data === d
    })
  })
}

FlameGraph.prototype.clearSelection = function clearSelection(){
  this.svg.selectAll('.cxviz-flame-selected').classed('cxviz-flame-selected', false).attr('fill', this.modColor)
}

FlameGraph.prototype.getClipId = function getClipId(d){
  return 'cxviz-flame_' + this.flameid.toString(32) + '_' + encodeURI(d.uid || 'root')
}

module.exports = FlameGraph

function percentFormat(d) {
  return d + '%'
}

},{"./flametree":27,"component-emitter":29,"cxviz-color":30,"cxviz-format":32,"d3":"d3","jquery":"jquery"}],29:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],30:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"randomcolor":31}],31:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],32:[function(require,module,exports){
'use strict';

var numeral  = require('numeral')
var prettyms = require('pretty-ms')

module.exports.mb = function mb(val){
  return numeral(val).format('0.0 b')
}

module.exports.ms = function millisecond(ms){
  return prettyms(ms)
}

module.exports.s = function second(s){
  return prettyms(s*1000)
}

module.exports.num = function num(val){
  return numeral(val).format('0.0 a')
}

module.exports.truncate = function truncate(str, front, back, options) {
  var opts = options || (typeof back === 'object') ? back : {}
  var ret = ''
  if (!str || (str.length <= front + back)) return str
  ret += str.slice(0, front)
  ret += opts.seperator || '...'
  if (typeof back == 'number') ret += str.slice(-back)
  return ret
}

},{"numeral":33,"pretty-ms":34}],33:[function(require,module,exports){
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var numeral,
        VERSION = '1.5.3',
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',
        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports);


    /************************************
        Constructors
    ************************************/


    // Numeral prototype object
    function Numeral (number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed (value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;
            
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral (n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) { // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) { // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) { // time
            output = formatTime(n, format);
        } else { // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral (n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency (n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage (n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);
        
        if (output.indexOf(')') > -1 ) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime (n) {
        var hours = Math.floor(n._value/60/60),
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
    }

    function unformatTime (string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
            // minutes
            seconds = seconds + (Number(timeArray[1]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + (Number(timeArray[0]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber (value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false, // force abbreviation to thousands
            abbrM = false, // force abbreviation to millions
            abbrB = false, // force abbreviation to billions
            abbrT = false, // force abbreviation to trillions
            abbrForce = false, // force abbreviation
            bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power+1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    numeral = function (input) {
        if (numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if(!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return numeral;
    };
    
    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }
        
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        
        return languages[key];
    };

    numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    numeral.zeroFormat = function (format) {
        zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function (format) {
        defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';
            
            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            
            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    
    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
        return mp > mn ? mp : mn;
        }, -Infinity);
    }        


    /************************************
        Numeral Prototype
    ************************************/


    numeral.fn = Numeral.prototype = {

        clone : function () {
            return numeral(this);
        },

        format : function (inputString, roundingFunction) {
            return formatNumeral(this, 
                  inputString ? inputString : defaultFormat, 
                  (roundingFunction !== undefined) ? roundingFunction : Math.round
              );
        },

        unformat : function (inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
                return inputString; 
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value : function () {
            return this._value;
        },

        valueOf : function () {
            return this._value;
        },

        set : function (value) {
            this._value = Number(value);
            return this;
        },

        add : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
            return this;
        },

        multiply : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) * (curr * corrFactor) /
                    (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);            
            return this;
        },

        difference : function (value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    // CommonJS module is defined
    if (hasModule) {
        module.exports = numeral;
    }

    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `numeral` as a global object via a string identifier,
        // for Closure Compiler 'advanced' mode
        this['numeral'] = numeral;
    }

    /*global define:false */
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return numeral;
        });
    }
}).call(this);

},{}],34:[function(require,module,exports){
'use strict';
var parseMs = require('parse-ms');
var plur = require('plur');
var isFinitePonyfill = require('is-finite');

module.exports = function (ms, opts) {
	if (!isFinitePonyfill(ms)) {
		throw new TypeError('Expected a finite number');
	}

	opts = opts || {};

	if (ms < 1000) {
		return Math.ceil(ms) + (opts.verbose ? ' ' + plur('millisecond', Math.ceil(ms)) : 'ms');
	}

	var ret = [];

	var add = function (val, long, short, valStr) {
		if (val === 0) {
			return;
		}

		var postfix = opts.verbose ? ' ' + plur(long, val) : short;

		ret.push((valStr || val) + postfix);
	};

	var parsed = parseMs(ms);

	add(parsed.days, 'day', 'd');
	add(parsed.hours, 'hour', 'h');
	add(parsed.minutes, 'minute', 'm');

	if (opts.compact) {
		add(parsed.seconds, 'second', 's');
		return '~' + ret[0];
	}

	var sec = ms / 1000 % 60;
	var secDecimalDigits = typeof opts.secDecimalDigits === 'number' ? opts.secDecimalDigits : 1;
	var secStr = sec.toFixed(secDecimalDigits).replace(/\.0$/, '');
	add(sec, 'second', 's', secStr);

	return ret.join(' ');
};

},{"is-finite":35,"parse-ms":44,"plur":37}],35:[function(require,module,exports){
'use strict';
var numberIsNan = require('number-is-nan');

module.exports = Number.isFinite || function (val) {
	return !(typeof val !== 'number' || numberIsNan(val) || val === Infinity || val === -Infinity);
};

},{"number-is-nan":36}],36:[function(require,module,exports){
'use strict';
module.exports = Number.isNaN || function (x) {
	return x !== x;
};

},{}],37:[function(require,module,exports){
'use strict';
module.exports = function (str, plural, count) {
	if (typeof plural === 'number') {
		count = plural;
		plural = str + 's';
	}

	return count === 1 ? str : plural;
};

},{}],38:[function(require,module,exports){
'use strict';

var d3      = require('d3')
var $       = require('jquery')
var color   = require('cxviz-color')
var Emitter = require('component-emitter')
var itemTemplate = require('./item.html')
var format = d3.format('.3s')

function RawTree() {
  if (!(this instanceof RawTree)) return new RawTree()
  return this
}

Emitter(RawTree.prototype)

//exported functions

RawTree.prototype.init = function init(element, options) {
  var self = this
  this.width = 1000
  this.height = 1000
  this.cb = options && options.cb
  this.color = (options && options.cb) || color
  this.el = element
  this.scale = 1

  this.root = d3.select(element).append('div')
    .attr('class', 'cxviz-rawtree')

  return this
}

RawTree.prototype.setActive = function setActive(){
  //set ourselves to the zoomControl
  this.cb.zoomControl.setZoom(this.zoom)
  this.cb.zoomControl.show()
}

RawTree.prototype.setInactive = function setInactive(){
  this.cb.zoomControl.hide()
}

RawTree.prototype.resize = function resize() {
  if (!this.lastData) return
  this.update(this.lastData, this.lastFunctions)
}

RawTree.prototype.update = function update(data, functions) {
  var self = this
  this.outerCost = data.costTree.childCost
  this.lastData = data
  this.lastFunctions = functions
  this.updateList(this.root, data.costTree, 0)
}

RawTree.prototype.updateList = function updateList(sel, root, level){
  level++
  var self = this
  if( root.children && root.children.length ){
    var update = sel.selectAll('ul.cxviz-rawtree-' + level).data([root], function key(d){ return d.uid})
    update.enter().append('ul')
      .attr('class', 'cxviz-rawtree-' + level )

    update.each(function(d){
      var ulSel = d3.select(this)
      self.updateItems(ulSel, d.children, level)
    })
    update.exit().remove()
  }
}

RawTree.prototype.updateItems = function updateItems(sel, items, level){
  var self = this
  if( items ){
    var update = sel.selectAll('li.cxviz-rawtree-'+ level).data(items, function key(d){ return d.uid })
    update.enter()
      .append('li')
      .attr('class', 'cxviz-rawtree-item cxviz-rawtree-' + level)
      .append('div')
        .on('mouseenter', function(d){ self.mouseEnter(d3.select(this), d)})
        .on('mouseleave', function(d){ self.mouseLeave(d3.select(this), d)})
        .on('click', function(d){ self.click(d3.select(this), d)})

    update.select('div').html(function(d){
      return itemTemplate({ item: d, msFormat: msFormat })
    })
    update.each(function(d){ return self.updateList(d3.select(this), d, level)})
    update.exit().remove()
  }
}

RawTree.prototype.mouseEnter = function mouseEnter(sel, d){
  var self = this
  this.emit('mouseenter', {
    type: "rawTree",
    item: d
  })
}

RawTree.prototype.mouseLeave = function mouseLeave(sel, d){
  var self = this
  this.emit('mouseleave', {
    type: 'rawTree',
    item: d
  })
}

RawTree.prototype.click = function click(sel, d){
  var self = this
  this.emit('click', {
    type: 'rawTree',
    item: d
  })

}

RawTree.prototype.clearSelection = function clearSelection(){
  this.root.selectAll('.cxviz-rawtree-selected').classed('cxviz-rawtree-selected', false)
}

RawTree.prototype.highlight = function (data) {
  var sel = d3.select(this.el).selectAll('.cxviz-rawtree-item')
  sel.each(function (item) {
    d3.select(this).classed('cxviz-rawtree-highlight', function(d){
      return data === d
    })
  })
}

RawTree.prototype.select = function(data) {
  var sel = d3.select(this.el).selectAll('.cxviz-rawtree-item')
  sel.each(function (item) {
    d3.select(this).classed('cxviz-rawtree-selected', function(d){
      return data === d
    })
  })
}


module.exports = RawTree


function msFormat(val){
  return format(val/1000000) + 's'
}

},{"./item.html":39,"component-emitter":40,"cxviz-color":15,"d3":"d3","jquery":"jquery"}],39:[function(require,module,exports){
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<strong>'+
((__t=( item.totalPct ))==null?'':__t)+
'%</strong>:'+
((__t=( msFormat(item.cost) ))==null?'':__t)+
' (<strong>'+
((__t=( item.selfPct ))==null?'':__t)+
'%</strong>:'+
((__t=( msFormat(item.selfCost) ))==null?'':__t)+
'</strong> self, <strong>'+
((__t=( item.childPct ))==null?'':__t)+
'%</strong>:'+
((__t=( msFormat(item.childCost) ))==null?'':__t)+
' child) - [<strong>'+
((__t=( item.visits ))==null?'':__t)+
'x</strong>] '+
((__t=( item.name ))==null?'':__t)+
'\n';
}
return __p;
};

},{}],40:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],41:[function(require,module,exports){
'use strict';

var d3           = require('d3');
var EventEmitter = require('events').EventEmitter;
var inherits     = require('util').inherits;
var Schema       = require('./lib/schema');
var format       = require('cxviz-format');
var Draw         = require('./lib/draw');

module.exports = Line;

var MAX_SERIES = 500;
var MAX_RECORDS = 5000;

var ONE_MIN_MS = 1000 * 60;
var ONE_HOUR_MS = ONE_MIN_MS * 60;
var ONE_DAY_MS = ONE_HOUR_MS * 24;
var ONE_WEEK_MS = ONE_DAY_MS * 7;
var DEFAULT_RATIO = 5;

var _dateBisect = d3.bisector(function(d) { return d._t; }).left;
// options:
//   type -- line, sparkline, miniline
//   height -- in px, [uses ratio of 2.5]
//   ratio -- ratio of width to height [2.5]
//   width -- in px, [parent width]
//   margin -- obj, in px, {top: 30, right: 50, bottom: 30, left: 50};
//   showXAxis -- bool [default depends on type]
//   showYAxis -- bool [default depends on type]
//   xGridTicks -- count [0]
//   yGridTicks -- count [1] (depending on type)
//   scale -- linear, log [linear]
//   interactive -- bool [default depends on graph type]
//   legend -- bool [default depends on graph type]
//   yMin -- value [undef] (override minimum to show on graph)
//   yMax -- value [undef] (override maximum to show on graph)
//   yMaxSoft -- soft max y value. Uses if max Y value < yMaxSoft [undef]
//   yMaxPaddingPct -- pct padding above the max Y value
//   gradient -- obj [undef] ({low: value, high: value}, threshold for gradient. included values are 'good')
//      TODO -- specify gradient from mean value?
// TODO other options:
//       bounding ranges/series? color options? error ranges?
//   formatter -- formatting function for data
function Line(parent, options) {
  if (!(this instanceof Line)) return new Line(parent, options);
  this.parent = d3.select(parent);
  this.options = options;
  this.schema = new Schema(options);
  this.reset(options);
  EventEmitter.call(this);
}
inherits(Line, EventEmitter);

// This is a harder reset than redraw() -- it actually removes the svg element in #parent and makes a new one.
Line.prototype.reset = function (options) {
  var svgElement = this.parent.selectAll('svg');
  options = options || {};
  svgElement.remove();

  this.raw = [];
  this.series = [];
  this.timeseries = [];

  // TODO ability to change chart size upon redraw()
  this.type = 'line';
  this.parentNode = this.parent.node();
  this.width = (this.parentNode && this.parentNode.offsetWidth) || 1000;
  this.height = options.height || Math.round(this.width / DEFAULT_RATIO);
  this.selectedTime = options.selectedTime || 0;
  this.margin = options.margin || {top: 20, right: 80, bottom: 30, left: 80}; // TODO better defaults?

  this.showXAxis = true;
  this.showYAxis = true;
  this.isHoverLineEnabled = true;
  this.xGridTicks = 0;
  this.yGridTicks = 1;
  this.yAxisTicks = 10;

  this.bgfill = 'none';

  this.formatter = options.formatter;

  this.yMin = options.yMin;
  this.yMax = options.yMax;
  if (options.yMaxPaddingPct != null) {
    this.yMaxPaddingPct = (options.yMaxPaddingPct < 1) ? options.yMaxPaddingPct : options.yMaxPaddingPct / 100;
  }

  this.scale = 'linear'; // TODO other scales, e.g. log
  this.interactive = true;
  this.legend = true;

  this.color = (options.color && options.color.moduleColor) || d3.scale.category10();

  // TODO y gridlines based on data extent?

  // Now that the defaults are set, override
  this.redraw(options);

  this.innerWidth = this.width - this.margin.right - this.margin.left;
  this.innerHeight = this.height - this.margin.top - this.margin.bottom;

  this.x = d3.time.scale()
      .range([0, this.innerWidth]);

  this.y = d3.scale.linear()
      .range([this.innerHeight, 0]);
  this.y1 = d3.scale.linear()
      .range([this.innerHeight, 0]);

  this.xAxis = d3.svg.axis()
      .scale(this.x)
      .orient('bottom');

  this.xGrid = d3.svg.axis()
      .scale(this.x)
      .orient('bottom')
      .ticks(this.xGridTicks)
      .tickSize(-this.innerHeight, 0, 0)
      .tickFormat('');

  this.yAxis = this._yAxis('y');
  this.y1Axis = this._yAxis('y1');

  this.yGrid = d3.svg.axis()
      .scale(this.y)
      .orient('left')
      .ticks(this.yGridTicks)
      .tickSize(-this.innerWidth, 0, 0)
      .tickFormat('');

  this.formatDate = d3.time.format('%Y-%m-%d %H:%M:%S.%L');

  var self = this;
  this.line = d3.svg.line()
      .x(function(d) { return self.x(d.date); })
      .y(function(d) { return self[self.schema.y(d)](d.val) })
      .defined(function(d) { return (d.val != null && !isNaN(d.val)) });
  this.area = d3.svg.area()
      .x(function(d){ return self.x(d.date);})
      .y0(function(d){ return self[self.schema.y(d)](d.val.min)})
      .y1(function(d){ return self[self.schema.y(d)](d.val.max)});

  this.svg = this.parent.append('svg')
      .attr('width', this.width)
      .attr('height', this.height);

  this.graph = this.svg.append('g')
      .attr('transform', 'translate(' + this.margin.left + ',' + this.margin.top + ')');

  this.graph.append('rect')
    .attr('class', 'underlay')
    .attr('width', this.innerWidth)
    .attr('height', this.innerHeight)
    //.style('fill-opacity', 0.25)
    .style('fill', this.bgfill);


};


// The initial draw of the data
Line.prototype.draw = function (data) {
  var self = this;

  if (!data || data.length === 0) {
    return new Error('No records to show.');
  }
  if (data.length > MAX_RECORDS) {
    return new Error('Too many records for Line.');
  }

  //if our width is different, hard reset
  //TODO--make resize more dynamic
  var tempwidth = (this.parentNode && this.parentNode.offsetWidth) || 4000;
  if( tempwidth != this.width ){
    this.reset(this.options);
  }
  this.raw = data;
  var series = [];
  var records = data.length;
  for (var i = 0; i < records; i++) {
    var record = data[i];
    if (series.length > MAX_SERIES) break;
    Object.keys(record).forEach(function (key) {
      if (series.length > MAX_SERIES){
        return;
      }
      if (key === '_t' || key === 'date'){
        return;
      }
      if( key === '__data'){
        return;
      }
      if (series.indexOf(key) < 0 && record[key] != null ){
        series.push(key);
      }
    });
    record.date = new Date(record._t);
  }

  if (series.length > MAX_SERIES) {
    console.log('Refusing to plot line graph with %s series', series.length);
    return new Error('Too many series detected');
  }

  var timeseries = series.map(function (name) {
      return {
        name: name,
        type: typeof record[name] == 'object' ? 'area' : 'line',
        values: data.filter(function (record) { return record[name] != null })
                    .map(function (record) { return {name: name, date: record.date, val: isNaN(record[name]) ? record[name] : +record[name]} })
      };
  });

  var yMin = (this.yMin == null) ? d3.min(timeseries.filter(function(d){ return self.schema.y(d) == 'y'}), function (s) { return d3.min(s.values, function (v) { return isNaN(v.val) ? v.val.min : v.val ; })}) : this.yMin;
  var yMax = (this.yMax == null) ? d3.max(timeseries.filter(function(d){ return self.schema.y(d) == 'y'}), function (s) { return d3.max(s.values, function (v) { return isNaN(v.val) ? v.val.max : v.val; })}) : this.yMax;

  var y1Min = (this.yMin == null) ? d3.min(timeseries.filter(function(d){ return self.schema.y(d) == 'y1'}), function (s) { return d3.min(s.values, function (v) { return isNaN(v.val) ? v.val.min : v.val ; })}) : this.yMin;
  var y1Max = (this.yMax == null) ? d3.max(timeseries.filter(function(d){ return self.schema.y(d) == 'y1'}), function (s) { return d3.max(s.values, function (v) { return isNaN(v.val) ? v.val.max : v.val; })}) : this.yMax;

  if (this.yMaxPaddingPct != null) {
    yMax = (this.yMaxPaddingPct + 1) * (yMax - yMin);
  }

  if (this.yMaxSoft != null && yMax < this.yMaxSoft) {
    yMax = this.yMaxSoft;
  }

  this.x.domain([data[0].date, data[data.length - 1].date]);
  this.y.domain([yMin, yMax]);
  this.y1.domain([y1Min, y1Max]);

  this.series = series;
  this.timeseries = timeseries;

  this._draw();

  var anomalies = self.graph.append('g')
    .attr('class', 'anomalies')
    .selectAll('path').data(data.filter(function(d, i){ return !!d.__data.lm_a }));
  anomalies.enter().append('path')
    .on('mouseover', anomalyHover)
    .on('click', anomalyClick);
  anomalies
    .attr('fill', function(d){ return d.__data.lm_a == 1 ? 'red' : '#ff7518' })
    .attr('stroke', 'none')
    .attr('d', triangle);
  anomalies.exit().remove();

  // Triangles
  function triangle(d) {
    var x = self.x(d.date);
    var y = self.innerHeight;
    var top = 'M ' + x + ' ' + (y + 3);
    var bottomLeft = 'L ' + (x - 5) + ' ' + (y + 13);
    var bottomRight = 'L ' + (x + 5) + ' ' + (y + 13);
    return top + ' ' + bottomLeft + ' ' + bottomRight + ' Z';
  }

  function anomalyHover(d) {
    self.hoverAt(d._t);
  }

  function anomalyClick(d) {
    self.emit('click', d.__data);
  }
};

// Redraw the data with different options
// Or if not drawn yet, simply set options
Line.prototype.redraw = function (options) {
  var self = this;
  // Apply type-specific defaults
  var type = options.type || this.type;
  switch (type) {
    case 'line':
      this.showXAxis = true;
      this.showYAxis = true;
      this.xGridTicks = 0;
      this.yGridTicks = 3;
      break;
    case 'miniline':
      this.showXAxis = false;
      this.showYAxis = true;
      this.xGridTicks = 0;
      this.yGridTicks = 0;
      this.yAxisTicks = 3;
      this.yTickSize = 0;
      this.margin = {top: 0, right: 0, bottom: 0, left: 35};
      this.interactive = false;
      this.legend = false;
      this.ratio = 7;
      this.bgfill = '#fff';
      this.yMaxPaddingPct = 0.1;
      break;
    case 'sparkline':
      this.showXAxis = false;
      this.showYAxis = false;
      this.xGridTicks = 0;
      this.yGridTicks = 0;
      this.yAxisTicks = 0;
      this.margin = {top: 0, right: 0, bottom: 0, left: 0};
      this.interactive = false;
      this.legend = false;
      this.ratio = 10;
      this.bgfill = '#fff';
      break;
    default:
      return new Error('Unknown chart type.');
  }
  // Simple options clobber. TBD: consider validity checks
  Object.keys(options).forEach(function (o) { self[o] = options[o] });
  if( this.color.moduleColor ) {
    this.color = this.color.moduleColor;
  }

  if (this.ratio && !options.width) {
    this.height = Math.round(this.width / this.ratio);
  }

  this.yAxis = this._yAxis();

  if (this.legend) {
    // TBD maybe make this more dynamic
    // Force 20 pixel margin at the top for the legend
    this.margin.top = 20;
  }

  // Don't attempt to re-draw if it hasn't been drawn yet (or no data)
  if (!this.timeseries.length) return;
  this._draw();
};

// New incoming data, transition in/transition out old
// Line.prototype.update = function (delta) {
//   // TODO...
// }
Line.prototype.update = Line.prototype.draw;


Line.prototype._draw = function () {
  var self = this;

  // TODO consider transitioning these out.
  this.graph.selectAll('.axis').remove();
  this.graph.selectAll('.grid').remove();
  this.graph.selectAll('.timeline').remove();
  this.graph.selectAll('#gradient').remove();
  this.graph.selectAll('.hover-line').remove();
  this.graph.selectAll('.select-line').remove();
  this.graph.selectAll('.overlay').remove();
  this.svg.selectAll('.x-legend').remove();
  this.svg.selectAll('.y-legend').remove();

  this.svg.selectAll('.underlay')
    .style('fill', this.bgfill);

  // Maybe add in some axes.
  if (this.showXAxis) {
    this.graph.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + this.innerHeight + ')')
        .call(this.xAxis);
  }

  if (this.showYAxis) {
    this.graph.append('g')
        .attr('class', 'y axis')
        .call(this.yAxis);
  }
  if( true /*this.showY1Axis*/){
    this.graph.append('g')
      .attr('class', 'y1 axis')
      .attr('transform', 'translate(' + (this.innerWidth) + ', 0)')
      .call(this.y1Axis);
  }

  if (this.yGridTicks > 0) {
    this.graph.append('g')
        .attr('class', 'y grid')
        .call(this.yGrid);
  }

  if (this.xGridTicks > 0) {
    this.graph.append('g')
        .attr('class', 'x grid')
        .attr('transform', 'translate(0,' + this.innerHeight + ')')
        .call(this.xGrid);
  }

  if (this.legend) {
    var earliest = this.raw[0]._t;
    var last = this.raw[this.raw.length - 1]._t;
    // Avg number of milli gap per record. Can be off if data is unevenly spaced.
    var avgGap = (last - earliest) / this.raw.length;
    if (avgGap > ONE_WEEK_MS) {
      this.formatDate = d3.time.format('%b %Y');
    }
    else if (avgGap > ONE_HOUR_MS * 12) {
      this.formatDate = d3.time.format('%Y-%m-%d (%a)');
    }
    else if (avgGap > ONE_MIN_MS * 30) {
      this.formatDate = d3.time.format('%Y-%m-%d (%a) %H:%M');
    }
    else if (avgGap > 1000 * 30) {
      // Bigger than 30s on average
      this.formatDate = d3.time.format('%Y-%m-%d %H:%M:%S');
    }

    // TODO checks related to total svg width

    this.xLegend = this.svg.append('g')
        .attr('class', 'x-legend')
        .attr('transform', 'translate(8, 15)');

    this.xLegend.append('text')
        .attr('class', 'legend-text');

    var nextX = 0;
    this.svg.append('g')
      .attr('class', 'y-legend')
      .attr('transform', 'translate(8, 15)')
      .selectAll('g')
      .data(this.series)
      .enter()
      .append('text')
      .attr('class', 'legend-text')
      .text(function (d) { return d; })
      .attr('x', function (d, i) {
        var offset = nextX;
        nextX += (d.length + 1) * 8;
        return offset;
      })
      .style('fill', function (d) { return self.color(d) });
  }

  switch(this.type) {
    case 'line':
    case 'miniline':
    case 'sparkline':
      return this._line();
    default:
      return new Error('Unknown chart type.');
  }


  var ts = self.selectedTime;
  if (ts) {
    var rec = self.getRecordAt(ts);
    var x = self.x(rec.date) | 0;
    self.selectionX = x;
    self.selectLine
      .attr('x1', x).attr('x2', x)
      .attr('style', 'display: visible')  ;
  }

};

Line.prototype._yAxis = function (type) {
  var axis = d3.svg.axis()
      .scale(this[type])
      .orient(type == 'y' ? 'left' : 'right');

  if (this.tickFormat) {
    axis.tickFormat(this.tickFormat);
  }
  else if (this.options.format && this.options.format[type] ) {
    axis.tickFormat(format[this.options.format[type]]);
  } else {
    axis.tickFormat(format.mb);
  }

  if (this.yAxisTicks != null) {
    axis.ticks(this.yAxisTicks);
  }

  if (this.yAxisValues != null) {
    axis.tickValues(this.yAxisValues);
  }

  if (this.yTickSize != null) {
    axis.tickSize(this.yTickSize);
  }

  return axis;
};

// Draw the loaded data as a line graph
Line.prototype._line = function () {
  var self = this;
  var draw = Draw(self);
  self.graph.selectAll('.timeline')
    .data(self.timeseries)
    .enter().append('g')
    .attr('class', 'timeline')
    .call(draw);

  if (self.interactive) {
    // TODO enable interactivity hooks/listeners
    self.hoverLineGroup = self.graph.append('g')
      .attr('class', 'hover-line');

    self.hoverLine = self.hoverLineGroup.append('line')
      // TODO x1 to 0/0, or max/max?
      .attr('x1', self.innerWidth).attr('x2', self.innerWidth)
      .attr('y1', 0).attr('y2', self.innerHeight);

    self.selectLineGroup = self.graph.append('g')
      .attr('class', 'select-line');
      //.attr('style', self.selectionX ? 'display: visible' : 'display: none')

    self.selectLine = self.selectLineGroup.append('line')
      // TODO x1 to 0/0, or max/max?
      .attr('x1', self.selectionX || self.innerWidth).attr('x2', self.selectionX || self.innerWidth)
      .attr('y1', 0).attr('y2', self.innerHeight);

    self.graph.append('rect')
      .attr('class', 'overlay')
      .attr('width', self.innerWidth)
      .attr('height', self.innerHeight)
      .on('mousemove', getHoverX)
      .on('mouseout', removeHoverX)
      .on('click', handleClick);
  }
  function handleClick(){
    var coords = d3.mouse(this)
    var ts = self.x.invert(coords[0]).getTime();
    var rec = self.getRecordAt(ts);
    var x = self.x(rec.date) | 1;
    self.selectionX = x;
    self.selectLine
      .attr('x1', x)
      .attr('x2', x)
      .attr('stroke', function (d, i) { return rec.__data.lm_a ? 'red' : 'black' })
      .attr('stroke-width', 1)
      .attr('style', 'display: visible');
    self.emit('click', rec.__data);
  }

  function removeHoverX() {
    self.hoverLine.attr('style', 'display: none');
  }
  function getHoverX() {
    var coords = d3.mouse(this);
    var ts = self.x.invert(coords[0]).getTime();
    self.hoverAt(ts);
    self.emit('hover', ts);
  }
};

Line.prototype.clearSelection = function clearSelection(){
  delete this.selectionX;
};
Line.prototype.setSelection = function setSelection(timestamp){

  var ts = timestamp;
  var rec = this.getRecordAt(ts);
  var x = this.x(rec.date) | 1;
  if (x === 0) {
    x = 1;
  }
  this.selectionX = x;
  this.hoverAt(ts);
};


Line.prototype.getRecordAt = function getRecordAt(timestamp){
  var self = this;
  var record = self.raw.slice(-1)[0];
  if (timestamp < record._t) {
    var entry = _dateBisect(self.raw, timestamp, 1);
    var left = self.raw[entry - 1];
    var right = self.raw[entry];
    if (!left || !right) {
      return right || left;
    }
    record = (timestamp - left._t > right._t - timestamp) ? right : left;
  }
  return record;
};
Line.prototype.disableHoverLine = function() {
  var self = this;
  self.isHoverLineEnabled = false;
};
Line.prototype.setSelection = function(timestamp) {
  var self = this;

  var record = self.getRecordAt(timestamp)

  // keep the line visible on first record
  var x = self.x(record.date) | 1;
  if (x === 0) {
    x = 1;
  }

  self.hoverLine
    .attr('x1', x)
    .attr('x2', x)
    .attr('stroke', function (d, i) { return record.__data.lm_a ? 'red' : 'black' })
    .attr('stroke-width', 1);

  self.selectionX = x;
  self.selectLine
    .attr('x1', x)
    .attr('x2', x)
    .attr('stroke', function (d, i) { return record.__data.lm_a ? 'red' : 'black' })
    .attr('stroke-width', 1)
    .attr('y1', 0).attr('y2', self.innerHeight)
    .attr('style', 'display: block');

  self.disableHoverLine();
};
// TODO emit/listen for highlight events when other graphs are highlighting
Line.prototype.hoverAt = function (timestamp) {
  var self = this;
  var record = self.getRecordAt(timestamp);
  var x = self.x(record.date) | 0;

  if (this.isHoverLineEnabled) {
    self.hoverLine
      .attr('x1', x)
      .attr('x2', x)
      .attr('stroke', function (d, i) {
        return record.__data.lm_a ? 'red' : 'black';
      })
      .attr('style', 'display: block')
      .attr('stroke-width', 1);
  }

  if (this.isHoverLineEnabled) {
    self.hoverLine
      .attr('x1', x)
      .attr('x2', x)
      .attr('stroke', function (d, i) {
        return record.__data.lm_a ? 'red' : 'black';
      })
      .attr('stroke-width', 1);
  }
  var formattedDate = self.formatDate(record.date);

  var colors = [];
  var legendValues = self.series.slice(0).sort(function(a, b) {
      if (record[a] == null){
        return b
      }
      if (record[b] == null) {
        return a
      }
      return record[b] - record[a]
    })
    .map(function (key) {
      var value;
      var f = self.schema.formatByKey(key);
      if( (record[key] !== undefined) && record[key] !== null) {
        if( typeof record[key] == 'object' ){
          value = [f(record[key].min), f(record[key].max)].join('/');
        } else {
          value = f(record[key]);
        }
      } else {
        value = 'N/A';
      }
      colors.push(self.color(key));
      return key + ': ' + value;
    });

  // TODO better handling when it runs off the end
  self.svg.selectAll('.y-legend')
      .attr('transform', 'translate(' + (formattedDate.length + 2) * 8 + ', 15)');
  var nextX = 0;
  self.svg.selectAll('.y-legend > .legend-text')
    .text(function (d, i) {
      return legendValues[i];
    })
    .attr('x', function (d, i) {
      var offset = nextX;
      nextX += (legendValues[i].length + 1) * 8;
      return offset;
    })
    .style('fill', function (d, i) {
      return colors[i]
    });


  self.xLegend.select('text').text(formattedDate);
};

},{"./lib/draw":42,"./lib/schema":43,"cxviz-format":32,"d3":"d3","events":9,"util":14}],42:[function(require,module,exports){
'use strict';
var d3 = require('d3')

module.exports = function Draw(self){
  var drawfun = drawItems
  function drawItems(sel){
    // the this pointer will come from d3.call
    var ret = sel.each(function(d){
      var type = self.schema.type(d)
      var itemSel = d3.select(this)
      if( type == 'line'){
        drawfun.line(itemSel)
      } else if (type == 'rect') {
        drawfun.rect(itemSel)
      } else if( type == 'range') {
        drawfun.range(itemSel)
      }
    })
    return ret
  }
  drawfun.line = function line(sel){
    sel.append('path')
      .attr('d', function (d) { return self[d.type](d.values) })
      .attr('class', self.schema.lineClass)
      .style('stroke', self.schema.stroke)
  }

  drawfun.rect = function rect(sel){
    var g = sel.append('g')
    var update = g.selectAll('.cxviz-timeseries-rect').data(function(d) { return d.values})
    update.enter()
      .append('rect')
        .attr('x', function(d) { return leftx(self, d)})
        .attr('y', function(d) { return y(self, d, 'max')})
        .attr('width', function(d){ return width(self, d)})
        .attr('height', function(d){ return height(self, d)})
        .attr('class', self.schema.lineClass)
        .style('stroke', self.schema.stroke)
  }

  drawfun.range = function range(sel){
    var seriesg = sel.append('g')
    var update = seriesg.selectAll('.cxviz-timeseries-rect').data(function(d) { return d.values})
    var g = update.enter()
      .append('g')
      .attr('class', self.schema.lineClass)
    g.append('line')
        .attr('x1', function(d) { return x(self, d)})
        .attr('y1', function(d) { return y(self, d, 'max')})
        .attr('x2', function(d){ return x(self, d)})
        .attr('y2', function(d){ return y(self, d, 'min')})
        .attr('class', 'cxviz-timeseries-range-vertical')
        .style('stroke', self.schema.stroke)
    g.append('line')
        .attr('x1', function(d) { return leftx(self, d) })
        .attr('y1', function(d) { return y(self, d, 'max')})
        .attr('x2', function(d){ return rightx(self, d)})
        .attr('y2', function(d){ return y(self, d, 'max')})
        .attr('class', 'cxviz-timeseries-range-endcap')
        .style('stroke', self.schema.stroke)
    g.append('line')
        .attr('x1', function(d) { return leftx(self, d)})
        .attr('y1', function(d) { return y(self, d, 'min')})
        .attr('x2', function(d){ return rightx(self, d)})
        .attr('y2', function(d){ return y(self, d, 'min') })
        .attr('class', 'cxviz-timeseries-range-endcap')
        .style('stroke', self.schema.stroke)
  }

  return drawfun
}

function leftx(viz, d){
  return viz.x(d.date) - (width(viz, d) / 2)
}

function rightx(viz, d){
  return viz.x(d.date) + (width(viz, d) / 2)
}

function x(viz, d){
  return viz.x(d.date)
}

function y(viz, d, key){
  return viz[viz.schema.y(d)](key ? d.val[key] : d.val)
}

function width(viz, d){
  var computed = viz.raw.length / viz.innerWidth
  if( computed < 7 ){
    return 7
  } else if (computed > 20 ){
    return 20
  } else {
    return computed
  }
}

function height(viz, d){
  var h = y(viz, d, 'min') - y(viz, d, 'max')
  return (h < 2 ) ? 2 : h
}

},{"d3":"d3"}],43:[function(require,module,exports){
'use strict';

var d3     = require('d3')
var format = require('cxviz-format')

module.exports = Schema

function Schema(options){
  if (!(this instanceof Schema)){
    return new Schema(options)
  }
  var self = this
  self.base = (options && options.keySchema) || {}
  self.color =  options.color || d3.scale.category10()

  //keep helper functions in the closure so that the d3 'this' pointer can be used
  self.y = function y(d){
    return (self.base[d.name] && self.base[d.name].y) || 'y'
  }

  self.lineClass = function lineClass(d){
    return (self.base[d.name] && self.base[d.name].class) || 'gradientLine'
  }

  self.stroke = function stroke(d){
    return self.color(d.name)
  }

  self.type = function type(d){
    return self.typeByKey(d.name)
  }

  self.typeByKey = function typeByKey(key){
    return (self.base[key] && self.base[key].type) || 'line'
  }

  self.formatByKey = function formatByKey(key){
    var y = self.y({name: key})
    if (options.format && options.format[y] && format[options.format[y]]) {
      return format[options.format[y]]
    } else {
      return format.num
    }
  }
}

},{"cxviz-format":32,"d3":"d3"}],44:[function(require,module,exports){
'use strict';
module.exports = function (ms) {
	if (typeof ms !== 'number') {
		throw new TypeError('Expected a number');
	}

	return {
		days: Math.floor(ms / 86400000),
		hours: Math.floor(ms / 3600000 % 24),
		minutes: Math.floor(ms / 60000 % 60),
		seconds: Math.floor(ms / 1000 % 60),
		milliseconds: Math.floor(ms % 1000)
	};
};

},{}],45:[function(require,module,exports){
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

},{}],46:[function(require,module,exports){
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

},{}],47:[function(require,module,exports){
(function (Buffer){
(function() {
  var crypt = require('crypt'),
      utf8 = require('charenc').utf8,
      bin = require('charenc').bin,

  // The core
  sha1 = function (message) {
    // Convert to byte array
    if (message.constructor == String)
      message = utf8.stringToBytes(message);
    else if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer == 'function' && Buffer.isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();

    // otherwise assume byte array

    var m  = crypt.bytesToWords(message),
        l  = message.length * 8,
        w  = [],
        H0 =  1732584193,
        H1 = -271733879,
        H2 = -1732584194,
        H3 =  271733878,
        H4 = -1009589776;

    // Padding
    m[l >> 5] |= 0x80 << (24 - l % 32);
    m[((l + 64 >>> 9) << 4) + 15] = l;

    for (var i = 0; i < m.length; i += 16) {
      var a = H0,
          b = H1,
          c = H2,
          d = H3,
          e = H4;

      for (var j = 0; j < 80; j++) {

        if (j < 16)
          w[j] = m[i + j];
        else {
          var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
          w[j] = (n << 1) | (n >>> 31);
        }

        var t = ((H0 << 5) | (H0 >>> 27)) + H4 + (w[j] >>> 0) + (
                j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 :
                j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 :
                j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 :
                         (H1 ^ H2 ^ H3) - 899497514);

        H4 = H3;
        H3 = H2;
        H2 = (H1 << 30) | (H1 >>> 2);
        H1 = H0;
        H0 = t;
      }

      H0 += a;
      H1 += b;
      H2 += c;
      H3 += d;
      H4 += e;
    }

    return [H0, H1, H2, H3, H4];
  },

  // Public API
  api = function (message, options) {
    var digestbytes = crypt.wordsToBytes(sha1(message));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

  api._blocksize = 16;
  api._digestsize = 20;

  module.exports = api;
})();

}).call(this,require("buffer").Buffer)
},{"buffer":5,"charenc":45,"crypt":46}],48:[function(require,module,exports){
module.exports.graph = require('./lib/graph')
module.exports.enhanceWaterfall = require('./lib/enhance')
module.exports.toTree = require("./lib/id_to_tree")
module.exports.costTree = require("./lib/cost_tree")

},{"./lib/cost_tree":49,"./lib/enhance":50,"./lib/graph":52,"./lib/id_to_tree":53}],49:[function(require,module,exports){
'use strict';

var _ = require('underscore')

module.exports              = treeCost
treeCost.extractCost        = extractCost
treeCost.summary            = summary

var toTree = require("./id_to_tree")

function treeCost(waterfall, functions) {
  var start = Date.now()
  var tree = toTree(waterfall.id)
  extractCost(tree, waterfall.segments, functions)
  tree.visits = waterfall.instance_count
  var ends = waterfall.segments.filter(function (seg) {
    return seg.type === "fn"
  }).map(function (seg) {
    return seg.end
  })
  var avgWallclock = Math.max.apply(null, ends)

  tree.avgWallclock = avgWallclock.toFixed(2)

  addSubtreeIds(tree)
  collapseCommonSubtrees(tree)
  addCostTreeDetails(tree)

  return tree
}

function extractCost(tree, segments, functions) {
  var i  = 0
  var id = 0

  var parent = []

  var fnName = function (id) {
    var name = functions[id].name
    var info = functions[id].module
    var mod = (info.name) ? info.name : info.filename
    if (mod === 'INTERNAL') return 'Uninstrumented Javascript'
    return mod + "#" + name
  }

  var walk = function walk(branch) {
    // (for now) skip roots
    branch.cost = 0
    branch.childCost = 0
    branch.visits = 0

    if (branch.id) {
      var seg       = segments[i++]
      branch.name   = fnName(seg.id)
      branch.visits = seg.visits
      branch.cost   = seg.end - seg.start
      branch.depth  = parent.length
      branch.seg    = seg
      branch.uid    = (id++).toString(36)

      if (parent.length) {
        parent[parent.length - 1].childCost += branch.cost
      }
      if (branch.id !== seg.id) {
        throw new Error("MISMATCH!!! saw " + seg.id + " expected " + branch.id)
      }
      if (parent.length && seg.end > parent[parent.length - 1].end) {
        throw new Error("OUT OF ORDER")
      }
    }
    parent.push(branch)
    branch.children.forEach(walk)
    parent.pop()
  }
  walk(tree)
}

function addSubtreeIds(tree) {
  tree.children.forEach(function (subtree) {
    addSubtreeIds(subtree)
  })
  tree.subtreeId = subtreeId(tree)
}

function collapseCommonSubtrees(costTree) {
  // look for common subtree candidates
  costTree.children.forEach(collapseCommonSubtrees)
  var recomputeSubtreeId = false;
  costTree.children = costTree.children.reduce(function (merged, curr) {
    for (var i = 0; i < merged.length; i++) {
      if (merged[i].subtreeId === curr.subtreeId) {
        mergeTrees(merged[i], curr)
        recomputeSubtreeId = true
        return merged
      }
    }
    merged.push(curr)
    return merged
  }, [])

  if( recomputeSubtreeId ){
    costTree.subTreeId = null
    costTree.subtreeId = subtreeId(costTree)
  }
}

function subtreeId(tree) {
  if( tree.subtreeId ){
    return tree.subtreeId
  }
  var id = tree.id + "("
  for (var i = 0; i < tree.children.length; i++) {
    id += subtreeId(tree.children[i])
  }
  id += ")"
  return id
}

// Merge two trees that are *already know* to be matching
function mergeTrees(left, right) {
  left.cost += right.cost
  left.childCost += right.childCost
  left.visits += right.visits
  for (var i = 0; i < left.children.length; i++) {
    mergeTrees(left.children[i], right.children[i])
  }
  return left
}

// Compute a text summary of a substree
function summary(tree, functions){
  var ret = {}
  var modCost = {}
  var costs = _.flatten(treeMap(tree))
  costs.sort(function(a,b){ return b.selfCost - a.selfCost })
  costs.forEach(function(d){
    if(d.seg && d.seg.type == 'fn'){
      var mod = functions[d.seg.id].module.name || functions[d.seg.id].module.filename
      var cost = d.cost - (d.childCost || 0)
      modCost[mod] = (modCost[mod] && modCost[mod] + cost) || cost
    }
  })
  var topMods = _.pairs(modCost).sort(function(a,b){ return b[1] - a[1]})
  ret.topMods = topMods.map(function(d){ return {name: d[0], cost: d[1]}})
  var totalCost = ret.topMods.reduce(function(prev, current){ return prev + current.cost}, 0)
  var modText = ret.topMods[0].name
  var percent = Math.floor((ret.topMods[0].cost / totalCost)*100) + '%'
  ret.summaryText = (modText === 'INTERNAL') ? 'Uninstrumented Javascript' : costs[0].name
  if( costs.length > 1 ){
    ret.summaryText = ret.summaryText + ' and ' + (costs.length - 1) + ' function' + ((costs.length > 2) ? 's' : '' )
  }
  ret.topCosts = costs
  if (tree.children) ret.syncCost = tree.children.reduce(function (prev, curr) { return prev + curr.cost }, 0)
  return ret
}

function treeMap(tree){
  if( tree.children && tree.children.length > 0 ){
    var t = [tree]
    t.push(tree.children.map(treeMap))
    return t
  } else {
    return [tree]
  }
}

function addCostTreeDetails(branch, outer) {
  var totalPct = 0
  var childPct = 0
  var selfPct = 0


  if (typeof outer == 'undefined') {
    branch.cost = branch.childCost
    outer = branch.cost
  }

  if (branch.cost > 0) {
    totalPct = parseFloat(((branch.cost / outer) * 100).toFixed(1))
    selfPct = totalPct
  }

  if (branch.childCost > 0) {
    childPct = parseFloat(((branch.childCost / outer) * 100).toFixed(1))
    selfPct = parseFloat((totalPct - childPct).toFixed(1))
  }

  branch.outerCost = outer
  branch.totalPct = totalPct
  branch.selfPct = selfPct
  branch.childPct = childPct
  branch.selfCost = branch.cost ? (branch.cost - branch.childCost) : 0

  if (branch.children.length) {
    branch.children.forEach(function (child) {
      addCostTreeDetails(child, outer)
    })
  }
}

},{"./id_to_tree":53,"underscore":60}],50:[function(require,module,exports){
'use strict';

var version     = require('../package.json').version
var stats       = require('./stats')
var summary     = require('./summary')
var subsegments = require('./subsegments')
var tree        = require('./tree')
var costTree    = require('./cost_tree')
var eventLoop   = require('./event_loop_agg')
var tags        = require('./tags')
var summaryStats = require("./timing_stats")

// NOTE:  the enhance API call modifies the waterfall in place.
// it will chop up segments to account for sub calls and compute nest levels
module.exports = function enhance(waterfall, options){
  waterfall.enhancedVersion = version
  var traceJsMicros = 0
  var traceOperatingTime = 0
  if( waterfall.waterfalls ){
    waterfall.waterfalls.forEach(function handleWaterfall(w){
      w.fnSegs = w.segments.filter(function(d){ return d.type == 'fn'})
      w.waitSegs = w.segments.filter(function(d){return d.type == 'wait'})
      tree(w)
      subsegments(w)
      w.costTree = costTree(w, waterfall.functions)
      eventLoop(w, waterfall.functions)
      summary(w, options)
      w.costSummary = costTree.summary(w.costTree, waterfall.functions)
      summaryStats(w)
      traceJsMicros += (w.timing_stats.jsMicros * w.instance_count)
      traceOperatingTime += (w.timing_stats.totalMicros * w.instance_count)
    })
  }
  stats.aggregateStats(waterfall)
  tags.enhanceTransactions(waterfall)

  // Append aggregate summary timing info to the entire tracefile
  var traceWindow = 0
  if (waterfall.transactions) {
    traceWindow = (waterfall.transactions.end - waterfall.transactions.start) * 1000
  }
  else {
    // no transaction log, so we don't have a specific window timeframe
    traceWindow = traceOperatingTime
  }

  // These summary_stats are *AGGREGATE*
  if (waterfall.summary_stats == null) {
    waterfall.summary_stats = {}
  }
  waterfall.summary_stats.jsMicros = traceJsMicros
  waterfall.summary_stats.totalMicros = traceOperatingTime
  waterfall.summary_stats.windowMicros = traceWindow
  // FIXME(setogit) set ceiling to avioid >100% or negative numbers
  //     Real fix is to ensure waterfall stats are calculated correctly. 
  waterfall.summary_stats.percentBlocked = Math.min(99.99, (traceJsMicros / traceWindow)*100)
  waterfall.summary_stats.percentAsync = (100 - waterfall.summary_stats.percentBlocked)
  waterfall.summary_stats.percentOperating = Math.min(99.99, (traceOperatingTime / traceWindow)*100)
  waterfall.summary_stats.percentIdle = (100 - waterfall.summary_stats.percentOperating)

  return waterfall
}

},{"../package.json":61,"./cost_tree":49,"./event_loop_agg":51,"./stats":54,"./subsegments":55,"./summary":56,"./tags":57,"./timing_stats":58,"./tree":59}],51:[function(require,module,exports){
'use strict';

var costTree = require('./cost_tree')

module.exports = eventLoopAggregate

var id = 0

function eventLoopAggregate(waterfall, functions){
  var agg      = []
  var waitSegs = waterfall.waitSegs

  if( !waitSegs ){
    waitSegs = waterfall.segments.filter(function(d){return d.type == 'wait'})
  } else {
    waitSegs = waitSegs.slice()
  }

  var final = 0
  waterfall.costTree && waterfall.costTree.children.forEach(function(c){
    var item = {}
    // if( final > 1 ){
    //   console.error('concurix-waterfalltransform error:  out of wait segments but still processing', waterfall.id )
    // }
    item.type                 = 'fn'
    item.id                   = c.id
    item.cost                 = c.cost
    item.visits               = c.visits
    item.name                 = getName(c)
    item.start                = c.seg.start
    item.end                  = c.seg.end
    item.costSubTree          = c
    item.uid                  = (id++).toString(36)
    item.costSummary          = costTree.summary(c, functions)
    agg.push(item)

    var wait = waitSegs.pop()
    if( wait ){
      var waitItem = {}
      waitItem.type   = 'wait'
      waitItem.id     = wait.id
      waitItem.cost   = wait.end - wait.start
      waitItem.start  = wait.start
      waitItem.end    = wait.end
      waitItem.visits = wait.visits
      waitItem.name   = wait.id
      waitItem.uid      = (id++).toString(36)
      agg.push(waitItem)
    } else {
      final++
    }
  })
  // if( waitSegs.length ){
  //   console.error('concurix-waterfalltransform error: wait segments still remaining but unprocessed', waterfall.id )
  // }
  waterfall.eventLoopAgg = agg

  //finally, sort the list by start time
  agg.sort(function s(a,b){ return a.start - b.start})
  return agg

  //TODO--this should really compute a better string, e.g. the most common module in the subtree or the one that takes
  //the most time.  for now go with the first name
  function getName(tree){
    return functions[tree.id].name
  }
}

},{"./cost_tree":49}],52:[function(require,module,exports){
var toTree = require('./id_to_tree')

module.exports = function graph(waterfall){
  var ret = {}
  //make a clean copy of the nodes
  var nodes = JSON.parse(JSON.stringify(waterfall.functions))
  var links = {}
  if( waterfall.waterfalls ){
    waterfall.waterfalls.forEach(handleWaterfall.bind(this, nodes, links))
  }
  ret.nodemap = nodes
  ret.linkmap = links
  return ret
}

//
function handleWaterfall(nodes, links, w){
  if( w.segments && w.segments.length === 0){
    return
  }

  var segs = w.segments.filter(function(d){ return d.type == 'fn'})
  var callbacks = w.segments.filter(function(d){return d.type == 'wait'})
  var tree = toTree(w.id)
  tree.children.forEach(dft)
  addCallbacks(callbacks)

  function dft(tree){
    var costs,
        s,
        node,
        inclusive,
        exclusive,
        child = 0
    if( !tree.id ){
      return
    }

    s = segs.shift()
    node = nodes[s.id]
    if( tree.children ){
      costs = tree.children.map(dft)
      costs.map(function(d){child += d})
      addLinks(tree, s)
    }
    inclusive = s.end - s.start
    exclusive = inclusive - child

    //initialize
    node.exclusive_duration   = node.exclusive_duration || 0
    node.child_duration       = node.child_duration || 0
    node.num_calls            = node.num_calls || 0
    node.duration             = node.duration || 0
    // set
    node.exclusive_duration   += exclusive
    node.child_duration       += child
    node.num_calls            += s.visits * w.instance_count
    node.duration             += inclusive

    return exclusive
  }

  function addLinks(tree, seg){
    tree.children.forEach(function(d){
      var id = [tree.id, d.id, 'invocation'].join('~')
      var link = links[id]
      if( !link ){
        link = {
          id: id,
          source: tree.id,
          target: d.id,
          type: 'invocation',
          num_calls: seg.visits * w.instance_count
        }
        links[id] = link
      } else {
        link.num_calls += seg.visits * w.instance_count
      }
    })
  }

  function addCallbacks(callbacks){
    callbacks.forEach(function(d){
      var id = [d.source, d.target, 'callback'].join('~')
      var link = links[id]
      if( !link ){
        link = {
          id: id,
          source: d.source,
          target: d.target,
          type: 'callback',
          num_calls: d.visits * w.instance_count,
          total_delay: d.end - d.start
        }
        links[id] = link
      } else {
        link.num_calls += d.visits * w.instance_count
        link.total_delay += (d.end - d.start)
      }
    })
  }

}

},{"./id_to_tree":53}],53:[function(require,module,exports){
"use strict";

module.exports = toTree

function toTree(id) {
  var trunk = new Branch("")
  id.split("~").forEach(function (idChunk) {
    walkTree(idChunk, trunk)
  })
  return trunk
}

function walkTree(id, root) {
  var nodeId = ""
  var lastAction = ""
  var newBranch
  var c
  var i
  var parent

  var nesting = [root]
  for (i = 0; i < id.length; i++) {
    c = id[i]
    parent = nesting[nesting.length - 1]
    if (c === "<") {
      if (nodeId.length) {
        newBranch = new Branch(nodeId)
        parent.children.push(newBranch)
        nesting.push(newBranch)
      }
      lastAction = "<"
      nodeId = ""
    }
    else if (c === ">") {
      if (lastAction === "<" && nodeId.length) {
        // leaf
        newBranch = new Branch(nodeId)
        parent.children.push(newBranch)
      }
      else {
        // not leaf, unwind
        nesting.pop()
      }
      lastAction = ">"
      nodeId = ""
    }
    else {
      nodeId += c
    }
  }
}

function Branch(id) {
  this.id = id
  this.children = []
}

},{}],54:[function(require,module,exports){
"use strict";

module.exports.aggregateStats = function aggregateStats(waterfall){
  var aggStats = {}
  var total = 0

  waterfall.waterfalls.forEach(function computeWaterfallStats(d){
    d.stats = module.exports.waterfallStats(d)
    total += d.stats.total_duration
  })

  aggStats.total_duration = total

  waterfall.aggregateStats = aggStats
  return waterfall
}

module.exports.waterfallStats = function waterfallStats(waterfall){
  var max = 0
  waterfall.segments.forEach(function maxEnd(d){
    if( d.end > max ){
      max = d.end
    }
  })
  var stats = {
    duration: max,
    total_duration:  max * waterfall.instance_count
  }
  return stats
}

},{}],55:[function(require,module,exports){
"use strict";

var _       = require('underscore')

module.exports = computeSubsegments

function computeSubsegments(w){
  if( w.segments && w.segments.length === 0){
    return
  }

  var tree          = w.tree
  var blockedMicros = 0
  var depth         = 0
  var maxEnd        = 0

  tree.children.forEach(dft)
  w.blockedMicros = blockedMicros
  w.maxEnd        = maxEnd

  function dft(tree){
    var costs,
        s,
        child = 0
    if( !tree.id ){
      return
    }

    s = tree.segment

    if( tree.children.length ){
      depth++
      costs = tree.children.map(dft)
      s.childSegments = _.flatten(costs)
      s.childSegments.map(function(d){child += d.exclusive})
      depth--
    }
    s.inclusive = s.end - s.start

    maxEnd = (s.end > maxEnd) ? s.end : maxEnd

    if (depth == 1) {
      blockedMicros += s.inclusive
    }

    s.exclusive = s.inclusive - child
    s.subSegments = invertChildSegments(s, s.childSegments)
    return {
      exclusive: s.exclusive,
      start: s.start,
      end: s.end
    }
  }
}

function invertChildSegments(seg, children){
  children = children || []
  var id = 1
  var subs = []
  var s = {
    start: seg.start,
    parent: seg,
    uid: subId(seg, id)
  }
  children.forEach(function(d){
    s.end = d.start
    s.exclusive = s.end - s.start
    subs.push(s)
    id++
    s = {
      start: d.end,
      parent: seg,
      uid: subId(seg, id)
    }
  })
  s.end = seg.end
  s.exclusive = s.end - s.start
  subs.push(s)
  return subs
}

function subId(seg, id){
  return [seg.uid, id.toString(36)].join(':')
}

},{"underscore":60}],56:[function(require,module,exports){
"use strict";

// note that summary views must be called AFTER subsegments are computed
module.exports = function waterfallSummary(w, options){
  if( w.segments && w.segments.length === 0){
    return
  }

  var factor = (options && options.summaryFactor) || 1000  //for a 1000 pixel output
  var threshold = w.maxEnd / factor
  var summary = {}
  var tree          = w.tree

  summary.subSegments = []
  summary.start = 0
  summary.end = w.maxEnd

  tree.children.forEach(dft)

  w.summary = summary
  function dft(tree){
    var cost,
        s,
        sub
    if( !tree.id ){
      return
    }

    s = tree.segment
    cost = s.end - s.start
    if( tree.children.length && cost > threshold ){
      summary.subSegments.concat(s.subSegments)
      tree.children.forEach(dft)
    } else {
      sub = {
        start     : s.start,
        end       : s.end,
        exclusive : s.end - s.start,
        parent    : s,
        uid        : s.uid + ':agg'
      }
      summary.subSegments.push(sub)
    }
  }
}

},{}],57:[function(require,module,exports){
'use strict';

module.exports.enhanceTransactions = function enhanceTransactions(waterfall){
  var tags = waterfall.transactions && waterfall.transactions.transactions
  if( tags ){
    waterfall.waterfalls.forEach(function(w){
      var found = false
      if( w.tags ){
        w.tags.forEach(function(tag){
          if( !tags[tag] ){
            //TODO: this case can happen right now with 0.0.3 and with appended error codes (e.g. 200) for web transactions.
            //console.error('concurix-waterfalltransform error: missing transaction id', tag, ' recovering...')
            tags[tag] = {}
          }
          found = true
          tags[tag].waterfalls = tags[tag].waterfalls || []
          tags[tag].waterfalls.push(w)
        })
      }
      if( !found ){
        tags['untagged'] = tags['untagged'] || {}
        tags['untagged'].waterfalls = tags['untagged'].waterfalls || []
        tags['untagged'].waterfalls.push(w)
      }
    })
  }

  // Append summary info
  Object.keys(tags).forEach(function (tag) {
    var waterfalls = tags[tag].waterfalls
    if (waterfalls == null) {
      return
    }
    var jsMicros = 0
    var totalMicros = 0

    waterfalls.forEach(function (wf) {
      jsMicros += (wf.timing_stats.jsMicros * wf.instance_count)
      totalMicros += (wf.timing_stats.totalMicros * wf.instance_count)
    })

    if (waterfalls.summary_stats == null) {
      waterfalls.summary_stats = {}
    }
    waterfalls.summary_stats.jsMicros = jsMicros
    waterfalls.summary_stats.totalMicros = totalMicros
    waterfalls.summary_stats.percentBlocked = ((jsMicros / totalMicros)*100)
    waterfalls.summary_stats.percentAsync = ((1-(jsMicros/ totalMicros))*100)
    // TODO average jsMicros or avg totalMicros?
  })
}

},{}],58:[function(require,module,exports){
"use strict";

module.exports = timingStats

function timingStats(waterfall) {
  var jsMicros = 0
  var lastEnd = 0.001
  waterfall.segments.forEach(function (seg) {
    if (seg.type === "fn" && seg.depth === 1) {
      jsMicros += seg.inclusive
    }
    if (seg.end > lastEnd) {
      lastEnd = seg.end
    }
  })

  // These summary stats are *PER INSTANCE*
  if (waterfall.timing_stats == null) {
    waterfall.timing_stats = {}
  }
  waterfall.timing_stats.jsMicros = jsMicros
  waterfall.timing_stats.totalMicros = lastEnd
  waterfall.timing_stats.percentBlocked = ((jsMicros / lastEnd)*100)
  waterfall.timing_stats.percentAsync = ((1-(jsMicros / lastEnd))*100)
}

},{}],59:[function(require,module,exports){
'use strict';

var toTree  = require("./id_to_tree")

module.exports = function tree(w){
  if( w.segments && w.segments.length === 0){
    return
  }
  var id       = 0
  var t        = toTree(w.id)
  var depth    = 0
  var maxDepth = 0
  var segs     = w.fnSegs.slice(0)

  t.children.forEach(dft)

  w.maxDepth   = maxDepth
  w.tree       = t

  //finally, add ids to the wait segments
  w.waitSegs.forEach(function waitId(d){
    id++
    d.uid = id.toString(36)
  })

  function dft(tree){
    var s

    if( !tree.id ){
      return
    }

    s            = segs.shift()
    if( !s ){
      console.error('yikes, missing segment for tree ', tree, JSON.stringify(w), segs, id)
    }
    id++
    s.uid         = id.toString(36)   //our id mechanism assumes that segment ordering is relatively stable between traces
    s.depth      = depth
    tree.segment = s

    if( tree.children.length ){
      depth++
      maxDepth = depth > maxDepth ? depth : maxDepth
      tree.children.forEach(dft)
      depth--
    }
  }
}

},{"./id_to_tree":53}],60:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],61:[function(require,module,exports){
module.exports={
  "name": "strong-trace-waterfalltransform",
  "version": "1.0.3",
  "description": "Transform waterfall trace data into other useful data structures",
  "main": "index.js",
  "scripts": {
    "test": "tap --timeout 300 test/index.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/strongloop/strong-trace-waterfalltransform.git"
  },
  "keywords": [
    "strongloop",
    "profiler",
    "monitoring"
  ],
  "license": "SEE LICENSE IN LICENSE.md",
  "author": {
    "name": "StrongLoop",
    "email": "engineering@strongloop.com"
  },
  "homepage": "https://github.com/strongloop/strong-trace-waterfalltransform",
  "jshintConfig": {
    "node": true,
    "browser": true,
    "devel": true,
    "jquery": true,
    "undef": true,
    "unused": true,
    "asi": true,
    "indent": 2,
    "eqnull": true,
    "loopfunc": true,
    "eqeqeq": false,
    "newcap": false,
    "globalstrict": true,
    "validthis": true
  },
  "devDependencies": {
    "strong-trace": "^1.2.0",
    "strong-trace-waterfalldata": "^1.0.0",
    "tap": "^0.4.12",
    "tape": "^2.13.4"
  },
  "dependencies": {
    "pegjs": "^0.8.0",
    "underscore": "^1.6.0"
  },
  "readmeFilename": "README.md",
  "gitHead": "ae3139ca4d94daec58e4e536143cd6abd33bb9fd",
  "bugs": {
    "url": "https://github.com/strongloop/strong-trace-waterfalltransform/issues"
  },
  "_id": "strong-trace-waterfalltransform@1.0.3",
  "_shasum": "11a38acfb4cf37fbebbe4dc4f62209d657c683eb",
  "_from": "strong-trace-waterfalltransform@>=1.0.0 <2.0.0",
  "_npmVersion": "2.14.7",
  "_nodeVersion": "0.10.40",
  "_npmUser": {
    "name": "admin",
    "email": "admin@strongloop.com"
  },
  "maintainers": [
    {
      "name": "admin",
      "email": "admin@strongloop.com"
    }
  ],
  "dist": {
    "shasum": "11a38acfb4cf37fbebbe4dc4f62209d657c683eb",
    "tarball": "http://ci.strongloop.com:4873/strong-trace-waterfalltransform/-/strong-trace-waterfalltransform-1.0.3.tgz"
  },
  "_resolved": "http://ci.strongloop.com:4873/strong-trace-waterfalltransform/-/strong-trace-waterfalltransform-1.0.3.tgz",
  "readme": "ERROR: No README data found!"
}

},{}],"d3":[function(require,module,exports){
(function (global){
// exports the already global d3 in a way that require() likes
// this is used by browserify in the strong-arc build process to replace
// references to require('d3') with require('./path/to/this/file')
module.exports = (window || global).d3;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"jquery":[function(require,module,exports){
(function (global){
// exports the already global jQuery in a way that require() likes
// this is used by browserify in the strong-arc build process to replace
// references to require('jquery') with require('./path/to/this/file')
module.exports = (window || global).jQuery;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1])("jquery")
});