'use strict';
var test  = require('tape')
var xform = require('../index')

//Run external tests
require("./id_to_tree")
require("./cost_tree")
require('./event_loop')
require('./tags')
require('./summary_stats')

var data = require('strong-trace-waterfalldata')

test('simple graph transform', function(t){
  var graph = xform.graph(data.express2)
  t.assert(graph)
  t.end()
})

test('simple waterfall enchance', function(t){
  var copy = JSON.parse(JSON.stringify(data.expressExample))
  var waterfall = xform.enhanceWaterfall(copy)
  waterfall.waterfalls.forEach(function(d){
    t.assert(d.maxDepth >= 0, 'maxDepth property is set')
    d.segments.forEach(function(seg){
      if( seg.type == 'fn'){
        t.assert(seg.depth >= 0, 'depth property is set')
        t.assert('exclusive' in seg, 'exlusive property set')
        t.assert(seg.subSegments.length >=1, 'subSegments exist and are not empty')
        t.assert(!seg.childSegments || seg.childSegments.length >= 1, 'childSegments properly formed')
        t.assert(seg.inclusive >= seg.exclusive, 'child time does not exceed inclusive time')
        if( seg.subSegments ){
          seg.subSegments.forEach(function(d){
            t.assert(d.parent, 'parent pointer valid')
          })
        }
      }
    })
  })
  t.assert(waterfall, 'waterfall found')
  t.end()
})

test('simple waterfall enhance v2', function(t){
  var copy = JSON.parse(JSON.stringify(data.express2))
  var waterfall = xform.enhanceWaterfall(copy)
  waterfall.waterfalls.forEach(function(d){
    t.assert(d.maxDepth >= 0, 'maxDepth property is set')
    d.segments.forEach(function(seg){
      if( seg.type == 'fn'){
        t.assert(seg.depth >= 0, 'depth property is set')
        t.assert('exclusive' in seg, 'exlusive property set')
        t.assert(seg.subSegments.length >=1, 'subSegments exist and are not empty')
        t.assert(!seg.childSegments || seg.childSegments.length >= 1, 'childSegments properly formed')
        t.assert(seg.inclusive >= seg.exclusive, 'child time does not exceed inclusive time')
        if( seg.subSegments ){
          seg.subSegments.forEach(function(d){
            t.assert(d.parent, 'parent pointer valid')
            t.assert(d.uid.split(':')[0] == d.parent.uid, 'subsegment id points to parent')
          })
        }
      } else {
        t.assert(seg.uid, 'wait id is set')
      }
    })
  })
  t.assert(waterfall, 'waterfall found')
  t.end()
})

test('simple summary test', function(t){
  var copy = JSON.parse(JSON.stringify(data.express2))
  var waterfall = xform.enhanceWaterfall(copy)
  waterfall.waterfalls.forEach(function(d){
    var totalSegs = 0

    t.assert('tree' in d, 'tree form of segments computed')
    t.assert(d.maxEnd >= 0, 'max property is set')
    t.assert('summary' in d, 'summary exists')
    t.assert(d.summary.subSegments.length, 'summary has entries')

    d.segments.forEach(function(s){ totalSegs += (s.subSegments && s.subSegments.length) || 0})
    t.assert(d.summary.subSegments.length <= totalSegs, 'summarysegments are smaller than total segments')
    //console.log(' summary vs total is ', d.summary.subSegments.length, totalSegs)
    d.summary.subSegments.forEach(function(s){
      t.assert(s.uid, 'summary subsegment has id')
    })
  })
  t.end()
})

test('test summaryText', function(t){
  var copy = JSON.parse(JSON.stringify(data.express2))
  var waterfall = xform.enhanceWaterfall(copy)
  waterfall.waterfalls.forEach(function(d){
    t.assert('costSummary' in d, 'costSummary exists')
    t.assert('summaryText' in d.costSummary, 'summaryText exists')
    t.assert('topCosts' in d.costSummary, 'topCosts exist')
    t.assert('topMods' in d.costSummary, 'topMosts exist')
  })
  t.end()
})

// test the glitch server sample data set, as this was the source of some bugs
// in the past.
// test('glitch server waterfall enchance', function(t){
//   var copy = JSON.parse(JSON.stringify(data.glitchserver))
//   var waterfall = xform.enhanceWaterfall(copy)
//   waterfall.waterfalls.forEach(function(d){
//     t.assert(d.maxDepth >= 0, 'maxDepth property is set')
//     d.segments.forEach(function(seg){
//       if( seg.type == 'fn'){
//         t.assert(seg.depth >= 0, 'depth property is set')
//         t.assert('exclusive' in seg, 'exlusive property set')
//         t.assert(seg.subSegments.length >=1, 'subSegments exist and are not empty')
//         t.assert(!seg.childSegments || seg.childSegments.length >= 1, 'childSegments properly formed')
//         t.assert(seg.inclusive >= seg.exclusive, 'child time does not exceed inclusive time')
//         if( seg.subSegments ){
//           seg.subSegments.forEach(function(d){
//             t.assert(d.parent, 'parent pointer valid')
//             t.assert(d.uid, 'uid is set')
//           })
//         }
//       }
//     })
//   })
//   t.assert(waterfall, 'waterfall found')
//   t.end()
// })
