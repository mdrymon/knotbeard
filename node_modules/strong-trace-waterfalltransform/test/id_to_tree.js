'use strict';

var test = require("tape")

var toTree = require("../lib/id_to_tree")

var data = require('strong-trace-waterfalldata')

test("simple", function (t) {
  var tree = toTree("<A<B>>")
  t.equal(tree.id, "", "Root id is empty string")
  t.equal(tree.children.length, 1, "One child at the root level")
  t.equal(tree.children[0].id, "A", "A is the first child")
  t.equal(tree.children[0].children.length, 1, "A has one child")
  t.equal(tree.children[0].children[0].id, "B", "B is A's child")
  t.equal(tree.children[0].children[0].children.length, 0, "B has no children")
  t.end()
})

test("multiple waits", function (t) {
  var tree = toTree("<A<B>>~<1>~<Z<Y><X>>")
  t.equal(tree.id, "", "Root id is empty string")
  t.equal(tree.children.length, 3, "three children at the root level")
  t.equal(tree.children[0].id, "A", "A is the first child")
  t.equal(tree.children[0].children.length, 1, "A has one child")
  t.equal(tree.children[0].children[0].id, "B", "B is A's child")
  t.equal(tree.children[0].children[0].children.length, 0, "B has no children")

  t.equal(tree.children[1].id, "1", "1 is the first child")
  t.equal(tree.children[1].children.length, 0, "1 has no child")

  t.equal(tree.children[2].id, "Z", "Z is the first child")
  t.equal(tree.children[2].children.length, 2, "Z has two children")
  t.equal(tree.children[2].children[0].id, "Y", "Y is Z's first child")
  t.equal(tree.children[2].children[1].id, "X", "X is Z's second child")
  t.equal(tree.children[2].children[0].children.length, 0, "Y has no children")
  t.equal(tree.children[2].children[1].children.length, 0, "X has no children")

  t.end()
})

test("legacyExpress", function (t) {
  data.expressExample.waterfalls.forEach(function (wf) {
    var tree = toTree(wf.id)
    validate(tree, wf.segments, t)
  })
  t.end()
})

test("express", function (t) {
  data.express2.waterfalls.forEach(function (wf) {
    var tree = toTree(wf.id)
    validate(tree, wf.segments, t)
  })
  t.end()
})

function validate(tree, segments, t) {
  var i = 0
  var depth = 0
  var parentStart = []
  var parentEnd = []

  tree.children.forEach(function (branch) {
    walk(branch)
  })

  function walk(branch) {
    var seg = segments[i++]
    t.equal(branch.id, seg.id, "Ids match")
    if (depth > 0) {
      var pStart = parentStart[parentStart.length - 1]
      var pEnd = parentEnd[parentEnd.length - 1]
      t.ok(seg.start >= pStart && seg.end <= pEnd, "Segment is validly nested")
    }

    parentStart.push(seg.start)
    parentEnd.push(seg.end)
    depth++
    branch.children.forEach(walk)
    depth--
    parentStart.pop()
    parentEnd.pop()
  }
}
