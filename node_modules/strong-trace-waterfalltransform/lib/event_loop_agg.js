'use strict';

var costTree = require('./cost_tree')

module.exports = eventLoopAggregate

var id = 0

function eventLoopAggregate(waterfall, functions){
  var agg      = []
  var waitSegs = waterfall.waitSegs

  if( !waitSegs ){
    waitSegs = waterfall.segments.filter(function(d){return d.type == 'wait'})
  } else {
    waitSegs = waitSegs.slice()
  }

  var final = 0
  waterfall.costTree && waterfall.costTree.children.forEach(function(c){
    var item = {}
    // if( final > 1 ){
    //   console.error('concurix-waterfalltransform error:  out of wait segments but still processing', waterfall.id )
    // }
    item.type                 = 'fn'
    item.id                   = c.id
    item.cost                 = c.cost
    item.visits               = c.visits
    item.name                 = getName(c)
    item.start                = c.seg.start
    item.end                  = c.seg.end
    item.costSubTree          = c
    item.uid                  = (id++).toString(36)
    item.costSummary          = costTree.summary(c, functions)
    agg.push(item)

    var wait = waitSegs.pop()
    if( wait ){
      var waitItem = {}
      waitItem.type   = 'wait'
      waitItem.id     = wait.id
      waitItem.cost   = wait.end - wait.start
      waitItem.start  = wait.start
      waitItem.end    = wait.end
      waitItem.visits = wait.visits
      waitItem.name   = wait.id
      waitItem.uid      = (id++).toString(36)
      agg.push(waitItem)
    } else {
      final++
    }
  })
  // if( waitSegs.length ){
  //   console.error('concurix-waterfalltransform error: wait segments still remaining but unprocessed', waterfall.id )
  // }
  waterfall.eventLoopAgg = agg

  //finally, sort the list by start time
  agg.sort(function s(a,b){ return a.start - b.start})
  return agg

  //TODO--this should really compute a better string, e.g. the most common module in the subtree or the one that takes
  //the most time.  for now go with the first name
  function getName(tree){
    return functions[tree.id].name
  }
}
