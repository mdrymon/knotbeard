'use strict';

var _ = require('underscore')

module.exports              = treeCost
treeCost.extractCost        = extractCost
treeCost.summary            = summary

var toTree = require("./id_to_tree")

function treeCost(waterfall, functions) {
  var start = Date.now()
  var tree = toTree(waterfall.id)
  extractCost(tree, waterfall.segments, functions)
  tree.visits = waterfall.instance_count
  var ends = waterfall.segments.filter(function (seg) {
    return seg.type === "fn"
  }).map(function (seg) {
    return seg.end
  })
  var avgWallclock = Math.max.apply(null, ends)

  tree.avgWallclock = avgWallclock.toFixed(2)

  addSubtreeIds(tree)
  collapseCommonSubtrees(tree)
  addCostTreeDetails(tree)

  return tree
}

function extractCost(tree, segments, functions) {
  var i  = 0
  var id = 0

  var parent = []

  var fnName = function (id) {
    var name = functions[id].name
    var info = functions[id].module
    var mod = (info.name) ? info.name : info.filename
    if (mod === 'INTERNAL') return 'Uninstrumented Javascript'
    return mod + "#" + name
  }

  var walk = function walk(branch) {
    // (for now) skip roots
    branch.cost = 0
    branch.childCost = 0
    branch.visits = 0

    if (branch.id) {
      var seg       = segments[i++]
      branch.name   = fnName(seg.id)
      branch.visits = seg.visits
      branch.cost   = seg.end - seg.start
      branch.depth  = parent.length
      branch.seg    = seg
      branch.uid    = (id++).toString(36)

      if (parent.length) {
        parent[parent.length - 1].childCost += branch.cost
      }
      if (branch.id !== seg.id) {
        throw new Error("MISMATCH!!! saw " + seg.id + " expected " + branch.id)
      }
      if (parent.length && seg.end > parent[parent.length - 1].end) {
        throw new Error("OUT OF ORDER")
      }
    }
    parent.push(branch)
    branch.children.forEach(walk)
    parent.pop()
  }
  walk(tree)
}

function addSubtreeIds(tree) {
  tree.children.forEach(function (subtree) {
    addSubtreeIds(subtree)
  })
  tree.subtreeId = subtreeId(tree)
}

function collapseCommonSubtrees(costTree) {
  // look for common subtree candidates
  costTree.children.forEach(collapseCommonSubtrees)
  var recomputeSubtreeId = false;
  costTree.children = costTree.children.reduce(function (merged, curr) {
    for (var i = 0; i < merged.length; i++) {
      if (merged[i].subtreeId === curr.subtreeId) {
        mergeTrees(merged[i], curr)
        recomputeSubtreeId = true
        return merged
      }
    }
    merged.push(curr)
    return merged
  }, [])

  if( recomputeSubtreeId ){
    costTree.subTreeId = null
    costTree.subtreeId = subtreeId(costTree)
  }
}

function subtreeId(tree) {
  if( tree.subtreeId ){
    return tree.subtreeId
  }
  var id = tree.id + "("
  for (var i = 0; i < tree.children.length; i++) {
    id += subtreeId(tree.children[i])
  }
  id += ")"
  return id
}

// Merge two trees that are *already know* to be matching
function mergeTrees(left, right) {
  left.cost += right.cost
  left.childCost += right.childCost
  left.visits += right.visits
  for (var i = 0; i < left.children.length; i++) {
    mergeTrees(left.children[i], right.children[i])
  }
  return left
}

// Compute a text summary of a substree
function summary(tree, functions){
  var ret = {}
  var modCost = {}
  var costs = _.flatten(treeMap(tree))
  costs.sort(function(a,b){ return b.selfCost - a.selfCost })
  costs.forEach(function(d){
    if(d.seg && d.seg.type == 'fn'){
      var mod = functions[d.seg.id].module.name || functions[d.seg.id].module.filename
      var cost = d.cost - (d.childCost || 0)
      modCost[mod] = (modCost[mod] && modCost[mod] + cost) || cost
    }
  })
  var topMods = _.pairs(modCost).sort(function(a,b){ return b[1] - a[1]})
  ret.topMods = topMods.map(function(d){ return {name: d[0], cost: d[1]}})
  var totalCost = ret.topMods.reduce(function(prev, current){ return prev + current.cost}, 0)
  var modText = ret.topMods[0].name
  var percent = Math.floor((ret.topMods[0].cost / totalCost)*100) + '%'
  ret.summaryText = (modText === 'INTERNAL') ? 'Uninstrumented Javascript' : costs[0].name
  if( costs.length > 1 ){
    ret.summaryText = ret.summaryText + ' and ' + (costs.length - 1) + ' function' + ((costs.length > 2) ? 's' : '' )
  }
  ret.topCosts = costs
  if (tree.children) ret.syncCost = tree.children.reduce(function (prev, curr) { return prev + curr.cost }, 0)
  return ret
}

function treeMap(tree){
  if( tree.children && tree.children.length > 0 ){
    var t = [tree]
    t.push(tree.children.map(treeMap))
    return t
  } else {
    return [tree]
  }
}

function addCostTreeDetails(branch, outer) {
  var totalPct = 0
  var childPct = 0
  var selfPct = 0


  if (typeof outer == 'undefined') {
    branch.cost = branch.childCost
    outer = branch.cost
  }

  if (branch.cost > 0) {
    totalPct = parseFloat(((branch.cost / outer) * 100).toFixed(1))
    selfPct = totalPct
  }

  if (branch.childCost > 0) {
    childPct = parseFloat(((branch.childCost / outer) * 100).toFixed(1))
    selfPct = parseFloat((totalPct - childPct).toFixed(1))
  }

  branch.outerCost = outer
  branch.totalPct = totalPct
  branch.selfPct = selfPct
  branch.childPct = childPct
  branch.selfCost = branch.cost ? (branch.cost - branch.childCost) : 0

  if (branch.children.length) {
    branch.children.forEach(function (child) {
      addCostTreeDetails(child, outer)
    })
  }
}
